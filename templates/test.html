<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Railway Connection Test</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        .test-section {
            margin-bottom: 30px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            background: #f9f9f9;
        }
        .test-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .test-item {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #ccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .test-item.pending {
            border-left-color: #ffa500;
        }
        .test-item.success {
            border-left-color: #4caf50;
            background: #e8f5e9;
        }
        .test-item.error {
            border-left-color: #f44336;
            background: #ffebee;
        }
        .test-name {
            font-weight: 600;
            color: #333;
        }
        .test-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-icon {
            font-size: 20px;
        }
        .status-text {
            font-weight: 600;
        }
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .test-details {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            font-size: 12px;
            color: #666;
            display: none;
        }
        .test-details.show {
            display: block;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
            margin: 10px 5px;
        }
        .btn:hover {
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .summary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .summary h2 {
            margin-bottom: 10px;
        }
        .summary-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }
        .stat {
            text-align: center;
        }
        .stat-value {
            font-size: 32px;
            font-weight: bold;
        }
        .stat-label {
            font-size: 14px;
            opacity: 0.9;
        }
        .expand-btn {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
        }
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Railway Connection Test</h1>
        <p class="subtitle">Diagnostic tool to test your application and Railway backend</p>
        
        <div class="summary">
            <h2>Test Summary</h2>
            <div class="summary-stats">
                <div class="stat">
                    <div class="stat-value" id="total-tests">0</div>
                    <div class="stat-label">Total Tests</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="passed-tests">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="failed-tests">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="pending-tests">0</div>
                    <div class="stat-label">Pending</div>
                </div>
            </div>
        </div>

        <div style="text-align: center; margin-bottom: 20px;">
            <button class="btn" onclick="runAllTests()">üîÑ Run All Tests</button>
            <button class="btn" onclick="clearResults()">üóëÔ∏è Clear Results</button>
        </div>

        <!-- Basic Connectivity Tests -->
        <div class="test-section">
            <h2>üåê Basic Connectivity</h2>
            <div id="test-basic-connectivity" class="test-item pending">
                <span class="test-name">Server Reachability</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
            <div id="test-health-endpoint" class="test-item pending">
                <span class="test-name">Health Endpoint (/health)</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
            <div id="test-metrics-endpoint" class="test-item pending">
                <span class="test-name">Metrics Endpoint (/metrics)</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
        </div>

        <!-- API Endpoint Tests -->
        <div class="test-section">
            <h2>üîå API Endpoints</h2>
            <div id="test-ip-info-endpoint" class="test-item pending">
                <span class="test-name">IP Info Endpoint (/api/get-ip-info)</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
            <div id="test-collect-endpoint" class="test-item pending">
                <span class="test-name">Collect Data Endpoint (/api/collect)</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
        </div>

        <!-- WebSocket Tests -->
        <div class="test-section">
            <h2>üîå WebSocket/SocketIO</h2>
            <div id="test-websocket-connection" class="test-item pending">
                <span class="test-name">WebSocket Connection</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
            <div id="test-websocket-events" class="test-item pending">
                <span class="test-name">WebSocket Events</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
        </div>

        <!-- Database Tests -->
        <div class="test-section">
            <h2>üíæ Database</h2>
            <div id="test-database-connectivity" class="test-item pending">
                <span class="test-name">Database Connectivity (via Health Check)</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
            <div id="test-database-operations" class="test-item pending">
                <span class="test-name">Database Operations (via Metrics)</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
        </div>

        <!-- File System Tests -->
        <div class="test-section">
            <h2>üìÅ File System</h2>
            <div id="test-filesystem-access" class="test-item pending">
                <span class="test-name">File System Access (via Health Check)</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
        </div>

        <!-- Environment Information -->
        <div class="test-section">
            <h2>‚ÑπÔ∏è Environment Information</h2>
            <div id="test-env-info" class="test-item success">
                <span class="test-name">Client Environment</span>
                <div class="test-status">
                    <span class="status-icon">‚úÖ</span>
                    <span class="status-text">Available</span>
                </div>
            </div>
            <div class="test-details show" id="env-details">
                <pre id="env-content"></pre>
            </div>
        </div>

        <!-- Response Times -->
        <div class="test-section">
            <h2>‚è±Ô∏è Response Times</h2>
            <div id="test-response-times" class="test-item pending">
                <span class="test-name">Endpoint Response Times</span>
                <div class="test-status">
                    <div class="spinner"></div>
                    <span class="status-text">Testing...</span>
                </div>
            </div>
            <div class="test-details" id="response-times-details">
                <pre id="response-times-content"></pre>
            </div>
        </div>
    </div>

    <script>
        let testResults = {};
        let socket = null;

        function updateSummary() {
            const tests = Object.values(testResults);
            const total = tests.length;
            const passed = tests.filter(t => t.status === 'success').length;
            const failed = tests.filter(t => t.status === 'error').length;
            const pending = tests.filter(t => t.status === 'pending').length;

            document.getElementById('total-tests').textContent = total;
            document.getElementById('passed-tests').textContent = passed;
            document.getElementById('failed-tests').textContent = failed;
            document.getElementById('pending-tests').textContent = pending;
        }

        function updateTestStatus(testId, status, message, details = null) {
            const testElement = document.getElementById(testId);
            const statusDiv = testElement.querySelector('.test-status');
            
            testResults[testId] = { status, message, details };
            
            testElement.className = `test-item ${status}`;
            
            let icon = '‚è≥';
            if (status === 'success') icon = '‚úÖ';
            else if (status === 'error') icon = '‚ùå';
            
            statusDiv.innerHTML = `
                <span class="status-icon">${icon}</span>
                <span class="status-text">${message}</span>
            `;
            
            if (details) {
                const detailsDiv = testElement.querySelector('.test-details') || 
                    (() => {
                        const div = document.createElement('div');
                        div.className = 'test-details';
                        testElement.appendChild(div);
                        return div;
                    })();
                detailsDiv.innerHTML = `<pre>${JSON.stringify(details, null, 2)}</pre>`;
                detailsDiv.classList.add('show');
            }
            
            updateSummary();
        }

        async function testBasicConnectivity() {
            try {
                const startTime = performance.now();
                const response = await fetch('/');
                const endTime = performance.now();
                const responseTime = (endTime - startTime).toFixed(2);
                
                if (response.ok) {
                    updateTestStatus('test-basic-connectivity', 'success', 
                        `Connected (${responseTime}ms)`, { status: response.status, responseTime });
                } else {
                    updateTestStatus('test-basic-connectivity', 'error', 
                        `Failed: ${response.status}`, { status: response.status });
                }
            } catch (error) {
                updateTestStatus('test-basic-connectivity', 'error', 
                    `Error: ${error.message}`, { error: error.message });
            }
        }

        async function testHealthEndpoint() {
            try {
                const startTime = performance.now();
                const response = await fetch('/health');
                const endTime = performance.now();
                const responseTime = (endTime - startTime).toFixed(2);
                const data = await response.json();
                
                if (response.ok && data.status) {
                    updateTestStatus('test-health-endpoint', 'success', 
                        `Healthy (${responseTime}ms)`, data);
                } else {
                    updateTestStatus('test-health-endpoint', 'error', 
                        `Unhealthy: ${data.status || 'unknown'}`, data);
                }
            } catch (error) {
                updateTestStatus('test-health-endpoint', 'error', 
                    `Error: ${error.message}`, { error: error.message });
            }
        }

        async function testMetricsEndpoint() {
            try {
                const startTime = performance.now();
                const response = await fetch('/metrics');
                const endTime = performance.now();
                const responseTime = (endTime - startTime).toFixed(2);
                const data = await response.json();
                
                if (response.ok) {
                    updateTestStatus('test-metrics-endpoint', 'success', 
                        `Working (${responseTime}ms)`, data);
                } else {
                    updateTestStatus('test-metrics-endpoint', 'error', 
                        `Failed: ${response.status}`, data);
                }
            } catch (error) {
                updateTestStatus('test-metrics-endpoint', 'error', 
                    `Error: ${error.message}`, { error: error.message });
            }
        }

        async function testIPInfoEndpoint() {
            try {
                const startTime = performance.now();
                const response = await fetch('/api/get-ip-info');
                const endTime = performance.now();
                const responseTime = (endTime - startTime).toFixed(2);
                const data = await response.json();
                
                if (response.ok && data.ip) {
                    updateTestStatus('test-ip-info-endpoint', 'success', 
                        `Working (${responseTime}ms)`, { ip: data.ip, provider: data.provider });
                } else {
                    updateTestStatus('test-ip-info-endpoint', 'error', 
                        `Failed: ${response.status}`, data);
                }
            } catch (error) {
                updateTestStatus('test-ip-info-endpoint', 'error', 
                    `Error: ${error.message}`, { error: error.message });
            }
        }

        async function testCollectEndpoint() {
            try {
                const testData = {
                    deviceInfo: { test: true },
                    fingerprint: { fp: 'test-fingerprint-' + Date.now() },
                    ipInfo: { ip: '127.0.0.1' },
                    timestamp: new Date().toISOString()
                };
                
                const startTime = performance.now();
                const response = await fetch('/api/collect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(testData)
                });
                const endTime = performance.now();
                const responseTime = (endTime - startTime).toFixed(2);
                const data = await response.json();
                
                if (response.ok && data.status === 'success') {
                    updateTestStatus('test-collect-endpoint', 'success', 
                        `Working (${responseTime}ms)`, data);
                } else {
                    updateTestStatus('test-collect-endpoint', 'error', 
                        `Failed: ${data.message || response.status}`, data);
                }
            } catch (error) {
                updateTestStatus('test-collect-endpoint', 'error', 
                    `Error: ${error.message}`, { error: error.message });
            }
        }

        function testWebSocketConnection() {
            return new Promise((resolve) => {
                let resolved = false;
                const timeout = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        updateTestStatus('test-websocket-connection', 'error', 
                            'Timeout: Connection failed', { error: 'Connection timeout' });
                        resolve();
                    }
                }, 10000);

                socket = io({
                    transports: ['websocket', 'polling'],
                    reconnection: false,
                    timeout: 5000
                });

                socket.on('connect', () => {
                    if (!resolved) {
                        resolved = true;
                        clearTimeout(timeout);
                        updateTestStatus('test-websocket-connection', 'success', 
                            'Connected', { id: socket.id, transport: socket.io.engine.transport.name });
                        resolve();
                    }
                });

                socket.on('connect_error', (error) => {
                    if (!resolved) {
                        resolved = true;
                        clearTimeout(timeout);
                        updateTestStatus('test-websocket-connection', 'error', 
                            `Connection failed: ${error.message}`, { error: error.message });
                        resolve();
                    }
                });
            });
        }

        function testWebSocketEvents() {
            return new Promise((resolve) => {
                if (!socket || !socket.connected) {
                    updateTestStatus('test-websocket-events', 'error', 
                        'WebSocket not connected', { error: 'Run WebSocket connection test first' });
                    resolve();
                    return;
                }

                let eventReceived = false;
                const timeout = setTimeout(() => {
                    if (!eventReceived) {
                        updateTestStatus('test-websocket-events', 'error', 
                            'No events received', { error: 'Event test timeout' });
                        resolve();
                    }
                }, 5000);

                socket.emit('ping', { test: true });
                
                socket.on('pong', () => {
                    eventReceived = true;
                    clearTimeout(timeout);
                    updateTestStatus('test-websocket-events', 'success', 
                        'Events working', { event: 'pong received' });
                    resolve();
                });

                // Also test user registration
                socket.emit('register_user', { 
                    entry_id: 999999, 
                    fingerprint: 'test-' + Date.now() 
                });

                socket.on('user_registered', (data) => {
                    if (!eventReceived) {
                        eventReceived = true;
                        clearTimeout(timeout);
                        updateTestStatus('test-websocket-events', 'success', 
                            'Events working', { event: 'user_registered received', data });
                        resolve();
                    }
                });
            });
        }

        function testDatabaseConnectivity() {
            // This is tested via health endpoint
            const healthTest = testResults['test-health-endpoint'];
            if (healthTest && healthTest.details) {
                const dbStatus = healthTest.details.database;
                if (dbStatus === 'ok') {
                    updateTestStatus('test-database-connectivity', 'success', 
                        'Database accessible', healthTest.details);
                } else {
                    updateTestStatus('test-database-connectivity', 'error', 
                        `Database issue: ${dbStatus}`, healthTest.details);
                }
            } else {
                updateTestStatus('test-database-connectivity', 'pending', 
                    'Waiting for health check...', null);
            }
        }

        function testDatabaseOperations() {
            // This is tested via metrics endpoint
            const metricsTest = testResults['test-metrics-endpoint'];
            if (metricsTest && metricsTest.details) {
                if (metricsTest.details.data_entries !== undefined) {
                    updateTestStatus('test-database-operations', 'success', 
                        'Database operations working', metricsTest.details);
                } else {
                    updateTestStatus('test-database-operations', 'error', 
                        'Database operations failed', metricsTest.details);
                }
            } else {
                updateTestStatus('test-database-operations', 'pending', 
                    'Waiting for metrics check...', null);
            }
        }

        function testFilesystemAccess() {
            // This is tested via health endpoint
            const healthTest = testResults['test-health-endpoint'];
            if (healthTest && healthTest.details) {
                const fsStatus = healthTest.details.filesystem;
                if (fsStatus === 'ok') {
                    updateTestStatus('test-filesystem-access', 'success', 
                        'File system accessible', healthTest.details);
                } else {
                    updateTestStatus('test-filesystem-access', 'error', 
                        `File system issue: ${fsStatus}`, healthTest.details);
                }
            } else {
                updateTestStatus('test-filesystem-access', 'pending', 
                    'Waiting for health check...', null);
            }
        }

        function displayEnvironmentInfo() {
            const envInfo = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                screen: {
                    width: screen.width,
                    height: screen.height,
                    colorDepth: screen.colorDepth
                },
                location: {
                    protocol: window.location.protocol,
                    host: window.location.host,
                    hostname: window.location.hostname,
                    port: window.location.port || 'default',
                    pathname: window.location.pathname
                },
                timestamp: new Date().toISOString()
            };
            
            document.getElementById('env-content').textContent = 
                JSON.stringify(envInfo, null, 2);
        }

        async function testResponseTimes() {
            const endpoints = [
                { name: 'Root (/)', url: '/' },
                { name: 'Health', url: '/health' },
                { name: 'Metrics', url: '/metrics' },
                { name: 'IP Info', url: '/api/get-ip-info' }
            ];
            
            const results = [];
            
            for (const endpoint of endpoints) {
                try {
                    const startTime = performance.now();
                    const response = await fetch(endpoint.url);
                    const endTime = performance.now();
                    const responseTime = (endTime - startTime).toFixed(2);
                    
                    results.push({
                        endpoint: endpoint.name,
                        url: endpoint.url,
                        status: response.status,
                        responseTime: responseTime + 'ms',
                        success: response.ok
                    });
                } catch (error) {
                    results.push({
                        endpoint: endpoint.name,
                        url: endpoint.url,
                        status: 'error',
                        responseTime: 'N/A',
                        success: false,
                        error: error.message
                    });
                }
            }
            
            const allSuccess = results.every(r => r.success);
            updateTestStatus('test-response-times', 
                allSuccess ? 'success' : 'error',
                allSuccess ? 'All endpoints responding' : 'Some endpoints failed',
                results);
            
            document.getElementById('response-times-content').textContent = 
                JSON.stringify(results, null, 2);
            document.getElementById('response-times-details').classList.add('show');
        }

        async function runAllTests() {
            // Reset all tests
            Object.keys(testResults).forEach(key => {
                const testElement = document.getElementById(key);
                if (testElement) {
                    testElement.className = 'test-item pending';
                    testElement.querySelector('.test-status').innerHTML = `
                        <div class="spinner"></div>
                        <span class="status-text">Testing...</span>
                    `;
                }
            });
            testResults = {};
            updateSummary();

            // Run tests in sequence
            displayEnvironmentInfo();
            
            await testBasicConnectivity();
            await testHealthEndpoint();
            await testMetricsEndpoint();
            await testIPInfoEndpoint();
            await testCollectEndpoint();
            
            // Test database and filesystem after health check
            testDatabaseConnectivity();
            testDatabaseOperations();
            testFilesystemAccess();
            
            // WebSocket tests
            await testWebSocketConnection();
            await testWebSocketEvents();
            
            // Response times
            await testResponseTimes();
            
            // Cleanup WebSocket
            if (socket) {
                socket.disconnect();
                socket = null;
            }
        }

        function clearResults() {
            testResults = {};
            document.querySelectorAll('.test-item').forEach(item => {
                item.className = 'test-item pending';
                item.querySelector('.test-status').innerHTML = `
                    <div class="spinner"></div>
                    <span class="status-text">Ready...</span>
                `;
                const details = item.querySelector('.test-details');
                if (details) {
                    details.classList.remove('show');
                    details.innerHTML = '';
                }
            });
            updateSummary();
        }

        // Auto-run tests on page load
        window.addEventListener('load', () => {
            displayEnvironmentInfo();
            setTimeout(runAllTests, 500);
        });
    </script>
</body>
</html>

